/* DO NOT EDIT: File is autogenerated */
package <%= schema.java.package %>;
<% set_iris_mode %>

@javax.annotation.Generated( "Domgen" )
@SuppressWarnings( { "UnusedDeclaration" } )
public class <%= schema.name %>Codec
{
  /* Type Codes */
<% schema.object_types.select{|o|!o.abstract? && o.iris.generate? }.each_with_index do |object_type, index|
%>  static final byte <%= uppercase_constantize(object_type.name) %>_TYPE_CODE = (byte)<%= index + 1 %>;
<% end %>

  /* Attr Masks */
<% schema.object_types.select{|o|!o.abstract? && o.iris.generate? }.each_with_index do |object_type, index|
%>  public static final int <%= uppercase_constantize(object_type.name) %>_CLIENT_TO_SERVER_ATTR_MASK = <%= object_type.attributes.select{|a| a.iris.client_side? && a.persistent? && !a.iris.runtime_managed? }.collect{|a| "#{j_classname(a.object_type.java.classname)}.#{uppercase_constantize(a.java.field_name)}_ATTR_ID" }.join(" | ") %>;
  static final int <%= uppercase_constantize(object_type.name) %>_SERVER_TO_SERVER_ATTR_MASK = <%= object_type.attributes.select{|a| a.persistent? && !a.iris.runtime_managed? }.collect{|a| "#{j_classname(a.object_type.java.classname)}.#{uppercase_constantize(a.java.field_name)}_ATTR_ID" }.join(" | ") %>;
<% end %>

  private static final Class<?>[] CLASSES_FOR_TYPE_CODE = {
    null,
    <%= schema.object_types.select{|o|!o.abstract? && o.iris.generate?}.collect{|o|"#{j_classname(o.java.classname)}.class"}.join(",\n    ") %>
  };

  private static final int[] SERVER_TO_SERVER_ATTR_MASK_FOR_TYPE_CODE = {
    0,
    <%= schema.object_types.select{|o|!o.abstract? && o.iris.generate?}.collect{|o|"#{uppercase_constantize(o.name)}_SERVER_TO_SERVER_ATTR_MASK"}.join(",\n    ") %>
  };

  public static Class<?> getClassForTypeCode( final int typeCode )
  {
    return CLASSES_FOR_TYPE_CODE[typeCode - 1];
  }

  public static int getTypeCodeForClass( final Class<?> type )
  {
    for( int i = 0; i < CLASSES_FOR_TYPE_CODE.length; i++ )
    {
      if( CLASSES_FOR_TYPE_CODE[i] == type )
      {
        return i;
      }
    }
    return -1;
  }

  public static java.util.Map<String, Object> readBean( final byte[] input, final int metadataMask )
    throws java.io.IOException, ClassNotFoundException
  {
    return readBean( new java.io.ObjectInputStream( new java.io.ByteArrayInputStream( input ) ), metadataMask );
  }

  private static java.util.Map<String, Object> readBean( final java.io.ObjectInput input, final int metadataMask )
     throws java.io.IOException, ClassNotFoundException
  {
      final java.util.Map<String, Object> data = new java.util.HashMap<String, Object>();

      final int typeCode = input.readByte();
      data.put( iris.beans.AbstractBean.TYPECODE, typeCode );

      final Object primaryKey = input.readObject();
      data.put( iris.persist.DatabasePeer.ID, primaryKey );

      final int attributesMask;
      if ( 0 != ( metadataMask & iris.beans.io.BeanCodec.MD_ATTR_MASK ) )
      {
         attributesMask = input.readInt();
      }
      else
      {
        attributesMask = SERVER_TO_SERVER_ATTR_MASK_FOR_TYPE_CODE[typeCode - 1];
      }
      if ( 0 != ( metadataMask & iris.beans.io.BeanCodec.MD_TO_AND_FROM_DATES ) )
      {
         final long to = input.readLong();
         if ( 0 != to )
         {
            data.put( iris.busobj.BusObjEntry.TO_DATE, new java.sql.Timestamp( to ) );
         }
      }

    <% schema.object_types.select{|o|!o.abstract? && o.iris.generate? }.each_with_index do |object_type, index|
%>if( <%= uppercase_constantize(object_type.name) %>_TYPE_CODE == typeCode )
      {
        read<%= object_type.name %>IntoMap( input, data, attributesMask );
      }
      else <% end %>
      {
        throw new IllegalStateException("Unknown typeCode " + typeCode );
      }
      return data;
   }

<% schema.object_types.select{|o|!o.abstract? && o.iris.generate? }.each do |object_type|
%>
  private static void read<%= object_type.name %>IntoMap( final java.io.ObjectInput input,
                           final java.util.Map<String, Object> data,
                           final int attributesMask )
      throws java.io.IOException, ClassNotFoundException
   {
<% object_type.attributes.select{|a| !a.primary_key? && !a.iris.runtime_managed? && a.persistent? && a.iris.client_side? }.each do |attribute|
     name = attribute.java.field_name
     attr_type = attribute.reference? ? attribute.referenced_object.primary_key.attribute_type : attribute.attribute_type
%>
      if( 0 != ( <%= j_classname(object_type.java.classname) %>.<%= uppercase_constantize(name) %>_ATTR_ID & attributesMask ) )
      {
        {
<% if attr_type == :integer %>          final Object value = input.readInt();
<% elsif attr_type == :i_enum %>          final Object value = <%= j_classname(object_type.java.classname) %>.<%= attribute.java.field_name %>Value.toValue( input.readByte() );
<% elsif attr_type == :boolean %>          final Object value = input.readBoolean();
<% elsif attr_type == :string || attr_type == :s_enum %>          final String string = input.readUTF();
          final Object value = "\0".equals( string ) ? null : string;
<% elsif attr_type == :datetime %>          final long time = input.readLong();
          final Object value = ( Long.MAX_VALUE == time ) ? null : new java.sql.Timestamp( time );
<% else %>          throw new IllegalStateException( "Unknown attribute type transmitted <%= attr_type %>" );<% end %>
          data.put( <%= j_classname(object_type.java.classname) %>.COLUMN_<%= uppercase_constantize(name) %>, value );
        }
      }
<% end %>
   }
<% end %>
}