/* DO NOT EDIT: File is autogenerated */
package <%= object_type.schema.java.package %>;
<% set_iris_mode %>

@javax.annotation.Generated( "Domgen" )
@SuppressWarnings( { "UnusedDeclaration", "UnnecessarilyQualifiedStaticUsage", "PointlessBitwiseExpression" } )
<%= j_class_definition(object_type) %>{
  public static final String TABLE_NAME = "<%= object_type.sql.table_name %>";
  /* Column Names */
<% object_type.declared_attributes.select{|a|!a.override? && a.persistent?}.each do |attribute|
%>  public static final String COLUMN_<%= uppercase_constantize(attribute.name) %> = "<%= attribute.sql.column_name %>";
<% end %>
<% object_type.declared_attributes.select{|a|!a.override? && !a.persistent?}.each do |attribute|
%>  public static final String COLUMN_<%= uppercase_constantize(attribute.name) %> = "<%= attribute.name %>"; /* Not Persistent */ 
<% end %>

<% object_type.iris.queries.each do |query| %>
  public static final String QUERY_<%= uppercase_constantize(query.name) %> = "<%= query.name %>";
  public static final String QUERY_<%= uppercase_constantize(query.name) %>_SQL = "<%= query.sql %>";
  public static final Class<<%= query.java_parameter_type %>> QUERY_<%= uppercase_constantize(query.name) %>_TYPE = <%= query.java_parameter_type %>.class;
<% end %>
  static final int MIN_ATTR_ID = <%= object_type.extends.nil? ? '1' : "#{j_classname(object_type.schema.object_type_by_name(object_type.extends).java.classname)}.MAX_ATTR_ID << 1"; %>;
<%
   last_attribute = "MIN_ATTR_ID"
   object_type.declared_attributes.select{|a|!a.abstract? && a.persistent?}.each_with_index do |attribute, index|
     last_attribute = "#{uppercase_constantize(attribute.java.field_name)}_ATTR_ID"
%>  public static final int <%= last_attribute %> = MIN_ATTR_ID << <%= index %>;
<% end
%>  static final int MAX_ATTR_ID = <%= last_attribute %>;

  static final int MIN_RELATION_ID = <%= object_type.extends.nil? ? '1' : "#{j_classname(object_type.schema.object_type_by_name(object_type.extends).java.classname)}.MIN_RELATION_ID << 1"; %>;
<%
   last_attribute = "MIN_RELATION_ID"
   object_type.referencing_attributes.select{|a|!a.abstract?}.each_with_index do |attribute, index|
     constant_name = uppercase_constantize(attribute.inverse_relationship_name)
     last_attribute = "#{constant_name}_RELATION_ID"
%>  public static final int <%= last_attribute %> = MIN_RELATION_ID << <%= index %>;
  public static final String <%= constant_name %>_RELATION_NAME = "<%= attribute.inverse_relationship_name %>";
<%
   end
%>  static final int MAX_RELATION_ID = <%= last_attribute %>;

<% object_type.declared_attributes.select {|a| a.attribute_type == :i_enum }.each do |attribute| %>
  @SuppressWarnings( { "PublicInnerClass" } )
  public static enum <%= attribute.java.field_name %>Value implements iris.beans.EnumValue
  {
    <%= attribute.values.collect {|k,v| "#{k}(#{v})" } .join(",\n    ")%>;
    private final int _value;

    <%= attribute.java.field_name %>Value( final int value )
    {
      _value = value;
    }

    public int getValue()
    {
      return _value;
    }

    public static <%= attribute.java.field_name %>Value toValue( final int value )
    {
      for( final <%= attribute.java.field_name %>Value v: <%= attribute.java.field_name %>Value.values() )
      {
        if( v.getValue() == value )
        {
           return v;
        }
      }
      return null;
    }
  }
<% end %>
  /*
   * Fields for the attributes
   */

<% object_type.declared_attributes.select {|a| !a.abstract? }.each do |attribute|
%>  private <%= j_attribute_type(attribute) %> <%= attribute.java.field_name %>;
<%  if attribute.reference? %>  private <%= attribute.referenced_object.primary_key.java.java_type %> <%= attribute.referencing_link_name %>;
<% end 
   end
   object_type.referencing_attributes.select {|a| !a.abstract? && !a.inherited? && a.inverse_relationship_type != :none }.
     each do |attribute|
     if attribute.abstract? || attribute.inherited? || attribute.inverse_relationship_type == :none
       # Ignore
     elsif attribute.inverse_relationship_type == :has_many
       type = j_classname(attribute.object_type.java.fully_qualified_name)
%>  private java.util.List<<%= type %>> <%= attribute.inverse_relationship_name %>Set;
  private java.util.List<<%= type %>> <%= attribute.inverse_relationship_name %>ReadOnlySet;
<% if !attribute.iris.inverse_sorter.nil? %>  private boolean <%= attribute.inverse_relationship_name %>SetNeedsSorting;
<% end
     elsif attribute.inverse_relationship_type == :has_one
       type = j_classname(attribute.object_type.java.fully_qualified_name)
%>  private <%= type %> <%= attribute.inverse_relationship_name %>;
<%
    end
   end
%>

/*
 * Accessors for the attributes
 */

<% object_type.declared_attributes.each do |attribute|
    name = attribute.java.field_name
    type = j_attribute_type(attribute)
    if attribute.abstract?
%>
  public abstract <%= type %> get<%= name %>();
<%   if attribute.reference?
%>
  public abstract <%= attribute.referenced_object.primary_key.java.java_type %> get<%= attribute.referencing_link_name %>();
<%
     end
     elsif attribute.reference?
      ref_type = attribute.referenced_object.primary_key.java.java_type
      ref_name = attribute.referencing_link_name
%>
  public <%= type %> get<%= name %>()
  {
    if( !isLinked() )
    {
      printWarning( "Accessing <%= attribute.object_type.name %>.<%= name %> on unlinked object");
    }
    else if( isCorrupt() )
    {
      printWarning( "Accessing <%= attribute.object_type.name %>.<%= name %> on corrupt object");
    }
<% if !attribute.nullable?
%>    else if( null == <%= name %> )
    {
      printWarning( "Accessing null <%= attribute.object_type.name %>.<%= name %> that was expected to be non-null");
    }
<% end
%>    return <%= name %>;
  }

  public void set<%= name %>( final <%= type %> value )
  {
<%= iris_pre_set_checks(attribute) %>
<%= j_return_if_value_same(name) %>
<%= j_remove_from_inverse(attribute) %>
    verifyValidLinkTarget( value );
    <%= name %> = value;
    //Only set the corresponding ID if the object is linked
    //or the resolved value is non-null. The reason for this
    //is that otherwise delinking during deletion will
    //set if to null and null ids will be saved to database
    //which is not desired behaviour
    if( isLinked() || null != value )
    {
      doSet<%= attribute.referencing_link_name %>( ( null == value ) ? null : value.get<%= attribute.referenced_object.primary_key.java.field_name %>() );
    }
<%= j_add_to_inverse(attribute) %>
  }

  public <%= ref_type %> get<%= ref_name %>()
  {
     return <%= ref_name %>;
  }

  public void set<%= ref_name %>( final <%= ref_type %> value )
  {
<%= iris_pre_set_checks(attribute) %>
<%= j_return_if_value_same(ref_name) %>
     if( isLinked() )
     {
       <%= type %> reference = null;
       if( null != value )
       {
         try
         {
           reference = iris.beans.BeanFactory.getManager().getBean( value, <%= type %>.class );
         }
         catch ( final iris.beans.MissingBeanException mbe )
         {
           printWarning("Unable to resolve value <%= attribute.object_type.name %>.<%= name %> on object");
           setCorrupt( true );
         }
       }
       set<%= name %>( reference );
    }
    else
    {
      doSet<%= ref_name %>( value );
    }
  }

    private void doSet<%= ref_name %>( final <%= ref_type %> value )
    {
  <%= iris_pre_set_checks(attribute) %>
  <%= j_return_if_value_same(ref_name) %>
      final <%= ref_type %> oldValue = <%= ref_name %>;
      <%= ref_name %> = value;
  <% if attribute.persistent? %>
      setChangeMaskBit( <%= uppercase_constantize(attribute.java.field_name) %>_ATTR_ID );
  <% end %>
      fireAttributeChange( COLUMN_<%= uppercase_constantize(attribute.java.field_name) %>, value, oldValue );
    }
<%
   else
%>
  public <%= type %> get<%= name %>()
  {
     return <%= name %>;
  }

  public void set<%= name %>( final <%= type %> value )
  {
     doSet<%= name %>( value );
  }

  private void doSet<%= name %>( final <%= type %> value )
  {
<%= iris_pre_set_checks(attribute) %>
<%= j_return_if_value_same(name) %>
    final <%= type %> oldValue = <%= name %>;
    <%= name %> = value;
<% if attribute.persistent? %>
    setChangeMaskBit( <%= uppercase_constantize(attribute.java.field_name) %>_ATTR_ID );
<% end %>
    fireAttributeChange( COLUMN_<%= uppercase_constantize(attribute.java.field_name) %>, value, oldValue );
  }

<%
  end
end
%>

<% object_type.referencing_attributes.each do |attribute|
  if attribute.abstract? || attribute.inherited? || attribute.inverse_relationship_type == :none
    # Ignore abstract attributes as will appear in child classes
    # Ignore inherited attributes as appear in parent class
    # Ignore attributes that have no inverse relationship
  elsif attribute.inverse_relationship_type == :has_many
    name = attribute.inverse_relationship_name
    type = j_classname(attribute.object_type.java.fully_qualified_name)
%>
  public final java.util.List<<%= type %>> get<%= name %>Set()
  {
<% if !attribute.iris.inverse_sorter.nil?
%>    if( <%= name %>SetNeedsSorting )
    {
      java.util.Collections.sort( safeGet<%= name %>Set(), <%= attribute.iris.inverse_sorter %>.COMPARATOR );
      <%= name %>SetNeedsSorting = false;
    }
<% end
%>    if( null == <%= name %>ReadOnlySet )
    {
      <%= name %>ReadOnlySet = java.util.Collections.unmodifiableList( safeGet<%= name %>Set() );
    }
    return <%= name %>ReadOnlySet;
  }

  protected final void add<%= name %>( final <%= type %> value )
  {
    if ( null == value )
    {
       throw new NullPointerException( "<%= name %>" );
    }
    else if ( value.isCorrupt() )
    {
       printWarning("Failed to add <%= name %> (" + value + ") to " + this + " as relation is corrupt." );
       return;
    }
    final java.util.List<<%= type %>> set = safeGet<%= name %>Set();
    if( !set.contains( value ) )
    {
       <% if !attribute.iris.inverse_sorter.nil? %><%= name %>SetNeedsSorting = true;<% end %>
       set.add( value );
       fireRelatedAdded( <%= j_classname(attribute.object_type.java.fully_qualified_name) %>.COLUMN_<%= uppercase_constantize(attribute.name) %>, value );
    }
  }

  protected final void remove<%= name %>( final <%= type %> value )
  {
    if ( null == value )
    {
       throw new NullPointerException( <%= uppercase_constantize(attribute.inverse_relationship_name) %>_RELATION_NAME );
    }
    final boolean removed = safeGet<%= name %>Set().remove( value );
    if( removed )
    {
       <% if !attribute.iris.inverse_sorter.nil? %><%= name %>SetNeedsSorting = true;<% end %>
       fireRelatedRemoved( <%= j_classname(attribute.object_type.java.fully_qualified_name) %>.COLUMN_<%= uppercase_constantize(attribute.name) %>, value );
    }
  }

  private java.util.List<<%= type %>> safeGet<%= name %>Set()
  {
    if( null == <%= name %>Set )
    {
      <%= name %>Set = new java.util.LinkedList<<%= type %>>();
    }
    return <%= name %>Set;
  }
<%
  elsif attribute.inverse_relationship_type == :has_one
    name = attribute.inverse_relationship_name
    type = j_classname(attribute.object_type.java.fully_qualified_name)
%>
  public final <%= type %> get<%= name %>()
  {
    return <%= name %>;
  }

  protected final void set<%= name %>( final <%= type %> value )
  {
    if ( null != value && value.isCorrupt() )
    {
       printWarning("Failed to add <%= name %> (" + value + ") to " + this + " as relation is corrupt." );
       return;
    }
    <%= name %> = value;
  }
<%
  end
end
%>
<%= j_to_string_methods(object_type) %>
}
