/* DO NOT EDIT: File is autogenerated */
package <%= object_type.schema.java.package %>;
<% set_iris_mode %>

@javax.annotation.Generated( "Domgen" )
@SuppressWarnings( { "NonFinalFieldReferencedInHashCode", "NonFinalFieldReferenceInEquals", "UnusedDeclaration", "UnnecessarilyQualifiedStaticUsage", "PointlessBitwiseExpression" } )
<%= j_class_definition(object_type) %>{
  public static final String MODEL_NAME = "<%= object_type.name %>";
<% if !object_type.abstract? %>  public static final String TABLE_NAME = "<%= object_type.sql.table_name %>";
<% end %>
  /* Column Names */
<% object_type.declared_attributes.select{|a|!a.override? && a.persistent? && !a.iris.runtime_managed?}.each do |attribute|
%>  public static final String COLUMN_<%= uppercase_constantize(attribute.name) %> = "<%= attribute.sql.column_name %>";
<% end %>
<% object_type.declared_attributes.select{|a|!a.override? && !a.persistent?}.each do |attribute|
%>  public static final String COLUMN_<%= uppercase_constantize(attribute.name) %> = "<%= attribute.name %>"; /* Not Persistent */
<% end %>
<% object_type.declared_attributes.select{|a|!a.override? && !a.length.nil? && !a.iris.runtime_managed?}.each do |attribute|
%>  public static final int COLUMN_<%= uppercase_constantize(attribute.name) %>_MAX_LENGTH = <%= attribute.length %>;
<% end %>

<% object_type.iris.criteria.each do |criterion| %>
  public static final String QUERY_<%= uppercase_constantize(criterion.name) %> = "<%= criterion.name %>";
<% end %>
  static final int MIN_ATTR_ID = <%= object_type.extends.nil? ? '1' : "#{j_classname(object_type.schema.object_type_by_name(object_type.extends).java.classname)}.MAX_ATTR_ID << 1"; %>;
<%
   last_attribute = "MIN_ATTR_ID"
   object_type.declared_attributes.select{|a|!a.abstract? && a.persistent? && !a.iris.runtime_managed?}.each_with_index do |attribute, index|
     last_attribute = "#{uppercase_constantize(attribute.java.field_name)}_ATTR_ID"
%>  public static final int <%= last_attribute %> = MIN_ATTR_ID << <%= index %>;
<% end
%>  public static final int MAX_ATTR_ID = <%= last_attribute %>; //Needs to be public as accessed via reflection

  static final int MIN_RELATION_ID = <%= object_type.extends.nil? ? '1' : "#{j_classname(object_type.schema.object_type_by_name(object_type.extends).java.classname)}.MIN_RELATION_ID << 1"; %>;
<%
   last_attribute = "MIN_RELATION_ID"
   object_type.referencing_attributes.select{|a|!a.abstract? && !a.iris.runtime_managed?}.each_with_index do |attribute, index|
     constant_name = uppercase_constantize(attribute.inverse_relationship_name)
     last_attribute = "#{constant_name}_RELATION_ID"
%>  public static final int <%= last_attribute %> = MIN_RELATION_ID << <%= index %>;
  public static final String <%= constant_name %>_RELATION_NAME = "<%= attribute.inverse_relationship_name %>";
<%
   end
%>  public static final int MAX_RELATION_ID = <%= last_attribute %>; //Needs to be public as accessed via reflection

<% object_type.declared_attributes.select {|a| a.attribute_type == :i_enum }.each do |attribute| %>
  @SuppressWarnings( { "PublicInnerClass" } )
  public static enum <%= attribute.java.field_name %>Value implements iris.beans.EnumValue
  {
    <%= attribute.values.collect {|k,v| "#{k}(#{v})" } .join(",\n    ")%>;
    private final int _value;

    <%= attribute.java.field_name %>Value( final int value )
    {
      _value = value;
    }

    public int getValue()
    {
      return _value;
    }

    public static <%= attribute.java.field_name %>Value toValue( final int value )
    {
      for( final <%= attribute.java.field_name %>Value v: <%= attribute.java.field_name %>Value.values() )
      {
        if( v.getValue() == value )
        {
           return v;
        }
      }
      return null;
    }
  }
<% end %>
  /*
   * Fields for the attributes
   */

<% object_type.declared_attributes.select {|a| !a.abstract? && !a.iris.runtime_managed? }.each do |attribute|
%>  private <%= j_attribute_type(attribute) %> <%= attribute.java.field_name %>;
<%  if attribute.reference? %>  private <%= attribute.referenced_object.primary_key.java.java_type %> <%= attribute.referencing_link_name %>;
<% end
   end
   object_type.referencing_attributes.select {|a| !a.abstract? && !a.inherited? && a.inverse_relationship_type != :none  && !a.iris.runtime_managed?}.
     each do |attribute|
     if attribute.abstract? || attribute.inherited? || attribute.inverse_relationship_type == :none
       # Ignore
     elsif attribute.inverse_relationship_type == :has_many
       type = j_classname(attribute.object_type.java.fully_qualified_name)
%>  private java.util.List<<%= type %>> <%= attribute.inverse_relationship_name %>Set;
  private java.util.List<<%= type %>> <%= attribute.inverse_relationship_name %>ReadOnlySet;
<% if !attribute.iris.inverse_sorter.nil? %>  private boolean <%= attribute.inverse_relationship_name %>SetNeedsSorting;
<% end
     elsif attribute.inverse_relationship_type == :has_one
       type = j_classname(attribute.object_type.java.fully_qualified_name)
%>  private <%= type %> <%= attribute.inverse_relationship_name %>;
<%
    end
   end
%>

/*
 * Accessors for the attributes
 */

<% object_type.declared_attributes.select{|a| !a.iris.runtime_managed?}.each do |attribute|
    name = attribute.java.field_name
    type = j_attribute_type(attribute)
    if attribute.abstract?
%>
  public abstract <%= type %> get<%= name %>();
<%   if attribute.reference?
%>
  public abstract <%= attribute.referenced_object.primary_key.java.java_type %> get<%= attribute.referencing_link_name %>();
<%
     end
     elsif attribute.reference?
      referenced_attribute = attribute.referenced_object.primary_key
      ref_type = referenced_attribute.java.java_type
      ref_name = attribute.referencing_link_name
%>
  public <%= type %> get<%= name %>()
  {
    if( !isLinked() )
    {
      printWarning( "Accessing <%= attribute.object_type.name %>.<%= name %> on unlinked object");
    }
    else if( isCorrupt() )
    {
      printWarning( "Accessing <%= attribute.object_type.name %>.<%= name %> on corrupt object");
    }
<% if !attribute.nullable?
%>    else if( null == <%= name %> )
    {
      printWarning( "Accessing null <%= attribute.object_type.name %>.<%= name %> that was expected to be non-null");
    }
<% end
%>    return <%= name %>;
  }

  public void set<%= name %>( final <%= type %> value )
  {
<% if attribute.immutable? %>
    if( isLinked() && !isNew() && !isLoading() )
    {
       throw new IllegalStateException( "Attempting to modify immutable attribute <%= attribute.name %> on non-new object" );
    }
<% end %>
<%= iris_nullable_check(attribute.name) if (!attribute.nullable? && !attribute.java.primitive?) %>
<%= j_return_if_value_same(name, attribute.java.primitive?,attribute.nullable?) %>
<%= j_remove_from_inverse(attribute) %>
    verifyValidLinkTarget( value );
    <%= name %> = value;
    //Only set the corresponding ID if the object is linked
    //or the resolved value is non-null. The reason for this
    //is that otherwise delinking during deletion will
    //set if to null and null ids will be saved to database
    //which is not desired behaviour
    if( isLinked() <% if !referenced_attribute.java.primitive? %>|| null != value <% end %>)
    {
      doSet<%= attribute.referencing_link_name %>( <% if !referenced_attribute.java.primitive? %>( null == value ) ? null :<% end %> value.get<%= attribute.referenced_object.primary_key.java.field_name %>() );
    }
<%= j_add_to_inverse(attribute) %>
  }

  public <%= ref_type %> get<%= ref_name %>()
  {
     return <%= ref_name %>;
  }

  public void set<%= ref_name %>( final <%= ref_type %> value )
  {
<%= iris_immutable_check(attribute.name) if attribute.immutable? %>
<%= iris_nullable_check(attribute.name) if (!attribute.nullable? && !referenced_attribute.java.primitive?) %>
<%= j_return_if_value_same(ref_name,referenced_attribute.java.primitive?,attribute.nullable?) %>
     if( isLinked() )
     {
       <%= type %> reference = null;
       <% if !referenced_attribute.java.primitive? %>if( null != value )<% end %>
       {
         try
         {
           reference = iris.beans.BeanFactory.getManager().getBean( value, <%= type %>.class );
         }
         catch ( final iris.beans.MissingBeanException mbe )
         {
           printWarning("Unable to resolve value <%= attribute.object_type.name %>.<%= name %> on object");
           setCorrupt( true );
         }
       }
       set<%= name %>( reference );
    }
    else
    {
      doSet<%= ref_name %>( value );
    }
  }

    private void doSet<%= ref_name %>( final <%= ref_type %> value )
    {
<%= iris_immutable_check(attribute.name) if attribute.immutable? %>
<%= iris_nullable_check(attribute.name) if (!attribute.nullable? && !referenced_attribute.java.primitive?) %>
<%= j_return_if_value_same(ref_name,referenced_attribute.java.primitive?,attribute.nullable?) %>
      final <%= ref_type %> oldValue = <%= ref_name %>;
      <%= ref_name %> = value;
  <% if attribute.persistent? %>
      setChangeMaskBit( <%= uppercase_constantize(attribute.java.field_name) %>_ATTR_ID );
  <% end %>
      fireAttributeChange( COLUMN_<%= uppercase_constantize(attribute.java.field_name) %>, value, oldValue );
    }
<%
   else
%>
  public <%= type %> get<%= name %>()
  {
     return <%= name %>;
  }

  public void set<%= name %>( final <%= type %> value )
  {
     doSet<%= name %>( value );
  }

  private void doSet<%= name %>( final <%= type %> value )
  {
<%= iris_immutable_check(attribute.name) if attribute.immutable? %>
<%= iris_nullable_check(attribute.name) if (!attribute.nullable? && !attribute.java.primitive?) %>
<%= j_return_if_value_same(name, attribute.java.primitive?,attribute.nullable?) %>
    final <%= type %> oldValue = <%= name %>;
    <%= name %> = value;
<% if attribute.persistent? %>
    setChangeMaskBit( <%= uppercase_constantize(attribute.java.field_name) %>_ATTR_ID );
<% end %>
    fireAttributeChange( COLUMN_<%= uppercase_constantize(attribute.java.field_name) %>, value, oldValue );
  }

<%
  end
end
%>

<% object_type.referencing_attributes.select{|a| !a.iris.runtime_managed?}.each do |attribute|
  if attribute.abstract? || attribute.inherited? || attribute.inverse_relationship_type == :none
    # Ignore abstract attributes as will appear in child classes
    # Ignore inherited attributes as appear in parent class
    # Ignore attributes that have no inverse relationship
  elsif attribute.inverse_relationship_type == :has_many
    name = attribute.inverse_relationship_name
    type = j_classname(attribute.object_type.java.fully_qualified_name)
%>
  public final java.util.List<<%= type %>> get<%= name %>Set()
  {
<% if !attribute.iris.inverse_sorter.nil?
%>    if( <%= name %>SetNeedsSorting )
    {
      java.util.Collections.sort( safeGet<%= name %>Set(), <%= attribute.iris.inverse_sorter %>.COMPARATOR );
      <%= name %>SetNeedsSorting = false;
    }
<% end
%>    if( null == <%= name %>ReadOnlySet )
    {
      <%= name %>ReadOnlySet = java.util.Collections.unmodifiableList( safeGet<%= name %>Set() );
    }
    return <%= name %>ReadOnlySet;
  }

  protected final void add<%= name %>( final <%= type %> value )
  {
    if ( null == value )
    {
       throw new NullPointerException( "<%= name %>" );
    }
    else if ( value.isCorrupt() )
    {
       printWarning("Failed to add <%= name %> (" + value + ") to " + this + " as relation is corrupt." );
       return;
    }
    final java.util.List<<%= type %>> set = safeGet<%= name %>Set();
    if( !set.contains( value ) )
    {
       <% if !attribute.iris.inverse_sorter.nil? %><%= name %>SetNeedsSorting = true;<% end %>
       set.add( value );
       fireRelatedAdded( <%= j_classname(attribute.object_type.java.fully_qualified_name) %>.COLUMN_<%= uppercase_constantize(attribute.name) %>, value );
    }
  }

  protected final void remove<%= name %>( final <%= type %> value )
  {
    if ( null == value )
    {
       throw new NullPointerException( <%= uppercase_constantize(attribute.inverse_relationship_name) %>_RELATION_NAME );
    }
    final boolean removed = safeGet<%= name %>Set().remove( value );
    if( removed )
    {
       <% if !attribute.iris.inverse_sorter.nil? %><%= name %>SetNeedsSorting = true;<% end %>
       fireRelatedRemoved( <%= j_classname(attribute.object_type.java.fully_qualified_name) %>.COLUMN_<%= uppercase_constantize(attribute.name) %>, value );
    }
  }

  private java.util.List<<%= type %>> safeGet<%= name %>Set()
  {
    if( null == <%= name %>Set )
    {
      <%= name %>Set = new java.util.LinkedList<<%= type %>>();
    }
    return <%= name %>Set;
  }
<%
  elsif attribute.inverse_relationship_type == :has_one
    name = attribute.inverse_relationship_name
    type = j_classname(attribute.object_type.java.fully_qualified_name)
%>
  public final <%= type %> get<%= name %>()
  {
    return <%= name %>;
  }

  protected final void set<%= name %>( final <%= type %> value )
  {
    if ( null != value && value.isCorrupt() )
    {
       printWarning("Failed to add <%= name %> (" + value + ") to " + this + " as relation is corrupt." );
       return;
    }
    <%= name %> = value;
  }
<%
  end
end
%>
<%= iris_to_string_methods(object_type) %>
<% if !object_type.abstract? %>
  @Override
   public void delink()
   {
      if ( !isLinked() )
      {
         return;
      }

      iris.beans.BeanFactory.getListener().deactivate();
      setUnloading();
      try
      {
<% object_type.referencing_attributes.select{|a| !a.iris.runtime_managed?}.each do |attribute|
  if attribute.inverse_relationship_type == :none
    # Ignore abstract attributes as will appear in child classes
    # Ignore inherited attributes as appear in parent class
    # Ignore attributes that have no inverse relationship
  elsif attribute.inverse_relationship_type == :has_many
    name = attribute.inverse_relationship_name
    type = j_classname(attribute.object_type.java.fully_qualified_name)
%>        {
          final java.util.ArrayList<<%= type %>> set = new java.util.ArrayList<<%= type %>>( get<%= name %>Set() );
          for ( final <%= type %> other : set )
          {
            other.delink();
          }
        }
<%
  elsif attribute.inverse_relationship_type == :has_one
    name = attribute.inverse_relationship_name
    type = j_classname(attribute.object_type.java.fully_qualified_name)
  %>      {
          final <%= type %> other = get<%= name %>();
          if( null != other )
          {
            other.delink();
          }
        }
<% end
end %>
         setLinked( false );
<% object_type.attributes.select {|a| a.reference? && !a.iris.runtime_managed?}.each do |attribute|
     name = attribute.java.field_name
     type = j_attribute_type(attribute)
%>
        set<%= name %>( null );
<% end %>
      }
      finally
      {
         unsetUnloading();
         iris.beans.BeanFactory.getListener().activate();
      }
   }

  @Override
  public void link( final boolean linkManaged )
  {
     if ( isLinked() )
     {
       return;
     }
     iris.beans.BeanFactory.getListener().deactivate();
     try
     {
       setLinked( true );
<% object_type.attributes.select {|a| a.reference? && !a.iris.runtime_managed?}.each do |attribute|
     name = attribute.java.field_name
     type = j_attribute_type(attribute)
     referenced_attribute = attribute.referenced_object.primary_key
     ref_type = referenced_attribute.java.java_type
     ref_primitive = referenced_attribute.java.primitive?
     ref_name = attribute.referencing_link_name
%>
      {
        final <%= ref_type %> id = get<%= ref_name %>();
        <%= type %> value = null;
        <% if attribute.nullable? %>if( null != id )<% end %>
        {
          try
          {
             final <%= type %> other = iris.beans.BeanFactory.getManager().getBean( id, <%= type %>.class, false );
             other.link( linkManaged );
             value = other;
          }
          catch ( final Exception e )
          {
             printWarning("Unable to resolve relationship <%= name %> on <%= object_type.name %>[" + this + "] with value " + id );
             iris.util.debug.IDebug.printException( e );
             setCorrupt( true );
          }
        }
        set<%= name %>( value );
      }
<% end %>
      if ( !iris.beans.BeanFactory.isClientSide() && linkManaged )
      {
<% object_type.referencing_attributes.select{|a| !a.iris.runtime_managed?}.each do |attribute|
     if object_type.name == :ManagementProject && (
        (attribute.object_type.name == :ManagementProject && attribute.name == :ParentTask) ||
        (attribute.object_type.name == :Deployment && attribute.name == :Task) )
       # Special hack to stop Management Projects loading all the database during startup
     elsif (attribute.iris.eager_fetch_type? && !attribute.object_type.iris.preload? && !attribute.object_type.iris.metadata? && !attribute.object_type.iris.metadata_that_can_change? )
%>
        try
        {
          final java.util.HashMap<String, Object> criteria = new java.util.HashMap<String, Object>();
          criteria.put( <%= j_classname(attribute.object_type.java.classname) %>.COLUMN_<%= uppercase_constantize(attribute.name) %>, get<%= object_type.primary_key.java.field_name %>() );
          iris.persist.Transaction.restoreSet( <%= j_classname(object_type.java.classname) %>.class, criteria, true );
        }
        catch ( final Exception e )
        {
          iris.util.debug.IDebug.printException( e );
          throw new RuntimeException( e.getMessage(), e );
        }<%
     end
   end
%>      }
     }
     finally
     {
       iris.beans.BeanFactory.getListener().activate();
     }
     fireObjectLinked();
  }

  @Override
  public int getClientToServerAttributeMask()
  {
    return <%= object_type.schema.name %>Codec.<%= uppercase_constantize(object_type.name) %>_CLIENT_TO_SERVER_ATTR_MASK;
  }

  @Override
  public int getServerToServerAttributeMask()
  {
    return <%= object_type.schema.name %>Codec.<%= uppercase_constantize(object_type.name) %>_SERVER_TO_SERVER_ATTR_MASK;
  }

  @Override
  public int getPersistChangeMask()
  {
    return <%= object_type.schema.name %>Codec.<%= uppercase_constantize(object_type.name) %>_SERVER_TO_SERVER_ATTR_MASK;
  }

  @Override
  public void writeTo( final java.io.ObjectOutput output, final boolean includeToDate, final int attributesMask )
     throws java.io.IOException
  {
    output.writeByte( <%= schema.name %>Codec.<%= uppercase_constantize(object_type.name) %>_TYPE_CODE );
    output.writeObject( get<%= object_type.primary_key.name %>() );

    if ( includeToDate )
    {
      final iris.busobj.BusObjEntry entry = iris.busobj.BusObjEntry.getEntry( this );
      if ( entry.getToDate() == null )
      {
        output.writeLong( 0 );
      }
      else
      {
        output.writeLong( entry.getToDate().getTime() );
      }
    }
    else
    {
      output.writeInt( attributesMask );
    }
<% object_type.attributes.select{|a| !a.iris.runtime_managed? && a.persistent? && a.iris.client_side? }.each do |attribute|
     name = attribute.reference? ? attribute.referencing_link_name : attribute.java.field_name
     attr_type = attribute.reference? ? attribute.referenced_object.primary_key.attribute_type : attribute.attribute_type
     is_primitive = attribute.reference? ? attribute.referenced_object.primary_key.java.primitive? : attribute.java.primitive?
%>
      if( 0 != (<%= uppercase_constantize(attribute.java.field_name) %>_ATTR_ID & attributesMask) )
      {
        try
        {
<% if is_primitive && attr_type == :integer %>          output.writeInt( get<%= name %>() );
<% elsif attr_type == :integer %>          output.writeInt( (get<%= name %>() == null) ? 0 : get<%= name %>() );
<% elsif attr_type == :i_enum %>          output.writeByte( (get<%= name %>() == null) ? (byte)0 : (byte)get<%= name %>().getValue() );
<% elsif is_primitive && attr_type == :boolean %>          output.writeBoolean( get<%= name %>() );
<% elsif attr_type == :boolean %>          output.writeBoolean( (get<%= name %>() == null) ? false : get<%= name %>() );
<% elsif attr_type == :string || attr_type == :s_enum %>          output.writeUTF( (get<%= name %>() == null) ? "\0" : get<%= name %>() );
<% elsif attr_type == :datetime %>          output.writeLong( (get<%= name %>() == null) ? Long.MAX_VALUE : get<%= name %>().getTime() );
<% else %>          throw new IllegalStateException( "Unknown attribute type transmitted <%= attr_type %>" );<% end %>
        }
        catch ( final RuntimeException e )
        {
           printWarning("Failed to write attribute <%= name %> of type <%= attr_type %> with value '" + get<%= name %>() + "'" );
           throw e;
        }
      }
<% end %>
      output.flush();
   }

  @Override
  protected void fromMap( final java.util.Map<String, Object> data )
  {
<% object_type.attributes.select{|a| !a.iris.runtime_managed? && a.persistent? }.each do |attribute|
     name = attribute.reference? ? attribute.referencing_link_name : attribute.java.field_name
     attr = attribute.reference? ? attribute.referenced_object.primary_key : attribute
     if attr.attribute_type == :i_enum
       prefix = "#{attr.java.non_primitive_java_type}.toValue"
       cast = "java.lang.Integer"
     else
       prefix = ""
       cast = attr.java.non_primitive_java_type
     end

%>
    if( data.containsKey( <%= j_classname(object_type.java.classname) %>.COLUMN_<%= uppercase_constantize(attribute.name) %> ) )
    {
      set<%= name %>( <%= prefix %> ( (<%= cast %>) data.get( <%= j_classname(object_type.java.classname) %>.COLUMN_<%= uppercase_constantize(attribute.name) %> ) ) );
    }
<% end %>
  }
<% end %>
}
