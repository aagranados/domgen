/* DO NOT EDIT: File is auto-generated */
package <%= entity.data_module.jpa.entity_package %>;

<%= description_javadoc_for(entity, "") %>@javax.annotation.Generated( "Domgen" )
@SuppressWarnings( { "UnusedDeclaration", "JavaDoc" } )
<%
   jpa_queries = entity.queries.select {|q| !q.jpa.native? }
   if !jpa_queries.empty? %>@javax.persistence.NamedQueries( value = {
<%= jpa_queries.collect { |q| "  @javax.persistence.NamedQuery( name = #{entity.jpa.name}.#{Domgen::Naming.uppercase_constantize(q.name)}, query = \"#{q.jpa.query_string.gsub('"',"\\\"")}\" )" }.join(",\n") %>
} )<% end %>
<%
   native_queries = entity.queries.select {|q| q.jpa.native? }
   if !native_queries.empty? %>@javax.persistence.NamedNativeQueries( value = {
<%= native_queries.collect { |q| "  @javax.persistence.NamedNativeQuery( name = #{entity.jpa.name}.#{Domgen::Naming.uppercase_constantize(q.name)}, query = \"#{q.jpa.query_string.gsub('"',"\\\"")}\"#{q.jpa.native? ? ", resultClass = #{entity.jpa.name}.class" : ""} )" }.join(",\n") %>
} )<% end %>
@javax.persistence.Access( javax.persistence.AccessType.FIELD )
@javax.persistence.Entity( name = "<%= entity.jpa.jpql_name %>" )<% if !entity.abstract? %>
@javax.persistence.Table( name = "<%= entity.jpa.table_name %>",
        schema = "<%= entity.data_module.sql.schema %>",
        uniqueConstraints = {<%=
  entity.attributes.select{|a|a.unique?}.collect{|a|
  "@javax.persistence.UniqueConstraint( columnNames = {\"#{a.sql.column_name}\"})"
  }.join(",\n        ")
%>})<%
else %>
@javax.persistence.Inheritance(strategy = javax.persistence.InheritanceType.TABLE_PER_CLASS)<%
end
%>
@javax.persistence.Cacheable( <%= entity.jpa.cacheable? ? "true" : "false" %> )
<% entity.codependent_constraints.each do |c| %>@<%= entity.jpa.name %>.<%= validation_name(c.name) %><% end %>
<% entity.dependency_constraints.each do |c| %>@<%= entity.jpa.name %>.<%= validation_name(c.name) %><% end %>
<% entity.incompatible_constraints.each do |c| %>@<%= entity.jpa.name %>.<%= validation_name(c.name) %><% end %>
<% entity.relationship_constraints.each do |c| %>@<%= entity.jpa.name %>.<%= validation_name(c.name) %><% end %>
<% entity.cycle_constraints.each do |c| %>@<%= entity.jpa.name %>.<%= validation_name(c.name) %><% end %>
public <%= entity.abstract? ? "abstract " : "" %>class <%= entity.jpa.name %>
<%= entity.extends ?
  "    extends #{entity.data_module.entity_by_name(entity.extends).jpa.qualified_name}\n" :
  "" %>    implements java.io.Serializable
{
<% if !entity.extends %>
  @javax.persistence.Transient
  private boolean _removed;
<% end %>
<% entity.queries.each do |query| %><%= description_javadoc_for(query) %>  public static final String <%= Domgen::Naming.uppercase_constantize(query.name) %> = "<%= query.qualified_name %>";
<%
  end
   entity.declared_attributes.select { |a| !a.abstract? && a.jpa.persistent? }.each do |attribute| %>
<%= j_jpa_field_attributes(attribute) -%>  private <%= attribute.jpa.java_type %> <%= attribute.jpa.field_name %>;
<% end %>
<% entity.referencing_attributes.
  select { |attribute| !(attribute.abstract? || attribute.inherited?) && attribute.inverse.jpa? && attribute.inverse.jpa.traversable? }.
  each do |attribute| %><%= j_declared_relation(attribute) %>
<% end %>
<%= j_constructors(entity) %>
<%= j_declared_attribute_and_relation_accessors(entity) %>
<%= j_equals_method(entity) %>
<%= j_to_string_methods(entity) %>

<% if !entity.extends %>
  protected final boolean removed()
  {
    return _removed;
  }

  protected final void verifyNotRemoved()
  {
    if( removed() )
    {
      throw new IllegalStateException( "Attempting to manipulate entity that has been removed" );
    }
  }
<% end %>

  @javax.persistence.PostRemove
  protected void postRemove()
  {
    if( removed() )
    {
      throw new IllegalStateException( "Attempting to remove already removed entity" );
    }
<% if entity.extends %>
    super.postRemove();
<% else %>
    _removed = true;
<% end %>
  }

  @javax.persistence.PreRemove
  protected void preRemove()
  {
<% entity.declared_attributes.
  select { |attribute| attribute.reference? && !(attribute.abstract? || attribute.inherited?) && attribute.inverse.jpa.traversable? && attribute.inverse.jpa.traversable? }.
  each do |attribute|
%>    if ( null != <%= attribute.jpa.field_name %> )
      {
        <%= attribute.jpa.field_name %>.remove<%= attribute.inverse.relationship_name %>( this );
      }
<% end %>  }

<%
      entity.codependent_constraints.each do |c|
        attributes = c.attribute_names.collect {|attribute_name| entity.attribute_by_name(attribute_name)}
-%>
<%= validation_prefix(c.name, entity) %>
        if( !(( <%= attributes.collect {|a| "object.#{getter_for(a)} == null"}.join(" && ") %> ) || (<%= attributes.collect {|a| "object.#{getter_for(a)} != null"}.join(" && ") %>) ) )
        {
          return false;
        }
<%= validation_suffix() %>
<% end -%>
<%
      entity.incompatible_constraints.each do |c|
        attributes = c.attribute_names.collect {|attribute_name| entity.attribute_by_name(attribute_name)}
-%>
<%= validation_prefix(c.name, entity) %>
        if( (<% attributes.each do |selected| -%>(<%= "null != object.#{getter_for(selected)}" %> && (<%= attributes.collect {|a| a == selected ? nil : "null != object.#{getter_for(a)}"}.compact.join(" || ") %>)) || <% end -%> false) )
        {
          return false;
        }
<%= validation_suffix() %>
<% end -%>
<%
      entity.relationship_constraints.each do |c|
        lhs = entity.attribute_by_name(c.lhs_operand)
        rhs = entity.attribute_by_name(c.rhs_operand)
        op = c.class.operators[c.operator]
        op = '==' if '=' == op
-%>
<%= validation_prefix(c.name, entity) %>
        if( <% if lhs.nullable? %>null != object.<%= getter_for(lhs) %> && <% end %><% if lhs.nullable? %>null != object.<%= getter_for(rhs) %> && <% end %>!( (object.<%= getter_for(lhs) %>) <%= op %> (object.<%= getter_for(rhs) %>) ) )
        {
          return false;
        }
<%= validation_suffix() %>
<% end -%>
<%
      entity.cycle_constraints.each do |c|
        target_attribute = entity.attribute_by_name(c.attribute_name)
        scoping_attribute = target_attribute.referenced_entity.attribute_by_name(c.scoping_attribute)

        current_entity = entity
        elements = c.attribute_name_path.collect do |element_name|
          new_attr = current_entity.attribute_by_name(element_name)
          current_entity = new_attr.referenced_entity
          new_attr
        end

-%>
<%= validation_prefix(c.name, entity) %>
        if( !(null == object.<%= getter_for(target_attribute) %> || (object.<%= getter_for(target_attribute) %>.<%= getter_for(scoping_attribute) %> == object.<%= elements.collect{|e|getter_for(e)}.join('.') %> ) ) )
        {
          return false;
        }
<%= validation_suffix() %>
<% end -%>
<%
      entity.dependency_constraints.each do |c|
        dependent_attributes = c.dependent_attribute_names.collect {|attribute_name| entity.attribute_by_name(attribute_name)}
        base_attribute = entity.attribute_by_name(c.attribute_name)
-%>
<%= validation_prefix(c.name, entity) %>
        if( !(null == object.<%= getter_for(base_attribute) %> || (<%= dependent_attributes.collect {|a| "object.#{getter_for(a)} != null"}.join(" && ") %>) ) )
        {
          return false;
        }
<%= validation_suffix() %>
<% end -%>
}
