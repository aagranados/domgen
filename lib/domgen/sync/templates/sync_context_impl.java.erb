/* DO NOT EDIT: File is auto-generated */
package <%= to_package(data_module.sync.qualified_sync_context_impl_name) %>;

/**

 Base class to extend to customize the synchronization process.

<code>
<pre>
@Singleton( name = SynchronizationContext.NAME )
@TransactionManagement( TransactionManagementType.BEAN )
@ConcurrencyManagement( ConcurrencyManagementType.BEAN )
@Local( SynchronizationContext.class )
public class SynchronizationContextEJB
  extends AbstractSynchronizationContext
{
}
</pre>
</code>
 */
public abstract class <%= data_module.sync.sync_context_impl_name %>
  implements <%= data_module.service_by_name(:SynchronizationContext).ejb.qualified_service_name %>
{
<% data_module.sync.entities_to_synchronize.each do |entity|
     fn = "#{entity.data_module.name}#{entity.name}"
     attr = entity.attributes.select{|a| a.sync? }
     db_attr = attr.select{|a| a.sql? && a.jpa? }
     recursive_attributes = attr.select{|a| a.reference? && a.referenced_entity.qualified_name == entity.qualified_name}

     attr.select{|a| a.sync.custom_transform? }.each do |attribute|
-%>
  <%= nullability_annotation(attribute.nullable?) %>
  @java.lang.Override
  public <%= attribute.jpa.java_type(:boundary) %> transform<%= fn %><%= attribute.name %>( <%= nullability_annotation(attribute.nullable?) %> final <%= attribute.jpa.java_type(:boundary) %> value )
  {
<% if attribute.sync.custom_transform? || !attribute.reference? -%>
    return value;
<% else -%>
<% if attribute.nullable? -%>
    if ( null == value )
    {
      return null;
    }
    else
    {
<% end -%>
      return (Integer) _entityManager.
        createNativeQuery( "SELECT <%= entity.sync.master_entity.attribute_by_name( attribute.primary_key? ? attribute.entity.name : attribute.name ).sql.quoted_column_name %> FROM <%= entity.sync.master_entity.sql.qualified_table_name %> WHERE <%= data_module.sql.dialect.quote('MasterID') %> = ?1" ).
        setParameter( 1, value ).
        getSingleResult();
<% if attribute.nullable? -%>
    }
<% end -%>
<% end -%>
  }

<% end -%>
<% if !entity.primary_key.generated_value? && entity.primary_key.attribute_type == :text
  s = data_module.service_by_name(:SynchronizationContext)
  m = s.method_by_name("Generate#{entity.data_module.name}#{entity.name}Key")
  -%>
  @javax.annotation.Nonnull
  public <%= m.return_value.ejb.java_type(:boundary) %> generate<%= entity.data_module.name %><%= entity.name %>Key(<%= m.parameters.collect{|p| "#{annotated_type(p, :ejb)} #{Domgen::Naming.camelize(p.name)}" }.join(', ') %>)
  {
    return java.util.UUID.randomUUID().toString();
  }
<% end -%>

  @javax.annotation.Nonnull
  @java.lang.Override
  public String getSqlToRetrieve<%= fn %>ListToUpdate( @javax.annotation.Nonnull final String mappingSourceCode )
  {
<%
  ref_index = 0
  attr_select = (db_attr.collect do |a|
    if a.reference?
      ref_index += 1
      if a.referenced_entity.abstract?
        index = -1
        "COALESCE(#{a.referenced_entity.subtypes.select{|a| !a.abstract? }.collect do |subtype| "R#{ref_index}#{index += 1}.#{subtype.sync.master_entity.attribute_by_name( subtype.root_entity.name ).sql.quoted_column_name}" end.join(', ')})"
      else
        "R#{ref_index}.#{a.referenced_entity.sync.master_entity.attribute_by_name( a.referenced_entity.root_entity.name ).sql.quoted_column_name}"
      end
    else
      "M.#{entity.sync.master_entity.attribute_by_name( a.primary_key? ? a.entity.root_entity.name : a.name ).sql.quoted_column_name}"
    end
  end + ["M.#{data_module.sql.dialect.quote('MappingID')}"]).join(', ')

  base_attr_select = db_attr.collect do |a|
    "M.#{entity.sync.master_entity.attribute_by_name( a.primary_key? ? a.entity.root_entity.name : a.name ).sql.quoted_column_name}"
  end.join(', ')

  criteria = "M.#{data_module.sql.dialect.quote('MasterSynchronized') } = 0 AND M.#{data_module.sql.dialect.quote('MappingSource') } = ?"
-%>
<% if recursive_attributes.size == 0 -%>
    return
      "SELECT <%= attr_select -%> " +
      "FROM <%= entity.sync.master_entity.sql.qualified_table_name %> M " +
<%
  ref_index = 0
  db_attr.select{|a| a.reference?}.collect do |a|
      ref_index += 1
      if a.referenced_entity.abstract?
  -%>
<% a.referenced_entity.subtypes.select{|a| !a.abstract? }.each_with_index do |subtype, index| -%>
      " LEFT JOIN <%= subtype.sync.master_entity.sql.qualified_table_name %> R<%= ref_index %><%= index %> ON R<%= ref_index %><%= index %>.<%= data_module.sql.dialect.quote('ID') %> = M.<%=entity.sync.master_entity.attribute_by_name( a.primary_key? ? a.entity.root_entity.name : a.name ).sql.quoted_column_name %> " +
<% end -%>
<% else -%>
      " LEFT JOIN <%= a.referenced_entity.sync.master_entity.sql.qualified_table_name %> R<%= ref_index %> ON R<%= ref_index %>.<%= data_module.sql.dialect.quote('ID') %> = M.<%=entity.sync.master_entity.attribute_by_name( a.primary_key? ? a.entity.root_entity.name : a.name ).sql.quoted_column_name %> " +
<%
      end
  end
-%>
      "WHERE <%= criteria %> AND M.<%= data_module.sql.dialect.quote('DeletedAt') %> IS NULL";
<% elsif recursive_attributes.size == 1 -%>
    return
      "WITH <%= fn %>List([ID], <%= base_attr_select.gsub('M.','') %>, [MappingID], [MasterSynchronized], [MappingSource], [Level]) AS (\n" +
      "  SELECT M.[ID], <%= base_attr_select %>, M.[MappingID], M.[MasterSynchronized], M.[MappingSource], 0 " +
      "  FROM <%= entity.sync.master_entity.sql.qualified_table_name %> M " +
      "  WHERE M.<%= data_module.sql.dialect.quote('DeletedAt') %> IS NULL AND M.<%= recursive_attributes[0].sql.quoted_column_name %> IS NULL " +
      "  UNION ALL\n" +
      "  SELECT M.[ID], <%= base_attr_select %>, M.[MappingID], M.[MasterSynchronized], M.[MappingSource], L.[Level] + 1 " +
      "  FROM <%= entity.sync.master_entity.sql.qualified_table_name %> M " +
      "  JOIN <%= fn %>List L ON L.[ID] = M.<%= recursive_attributes[0].sql.quoted_column_name %> " +
      "  WHERE M.<%= data_module.sql.dialect.quote('DeletedAt') %> IS NULL " +
      " )\n " +
      "  SELECT <%= attr_select -%> " +
      "  FROM <%= fn %>List M" +
<%
  ref_index = 0
  db_attr.select{|a| a.reference?}.collect do |a|
      ref_index += 1
      if a.referenced_entity.abstract?
  -%>
<% a.referenced_entity.subtypes.select{|a| !a.abstract? }.each_with_index do |subtype, index| -%>
      " LEFT JOIN <%= subtype.sync.master_entity.sql.qualified_table_name %> R<%= ref_index %><%= index %> ON R<%= ref_index %><%= index %>.<%= data_module.sql.dialect.quote('ID') %> = M.<%=entity.sync.master_entity.attribute_by_name( a.primary_key? ? a.entity.root_entity.name : a.name ).sql.quoted_column_name %> " +
<% end -%>
<% else -%>
      " LEFT JOIN <%= a.referenced_entity.sync.master_entity.sql.qualified_table_name %> R<%= ref_index %> ON R<%= ref_index %>.<%= data_module.sql.dialect.quote('ID') %> = M.<%=entity.sync.master_entity.attribute_by_name( a.primary_key? ? a.entity.root_entity.name : a.name ).sql.quoted_column_name %> " +
<%
      end
  end
-%>
      "  WHERE <%= criteria %> " +
      "  ORDER BY M.Level ASC ";
<% else -%>
    /*
    return
      "SELECT <%= attr_select -%> " +
      "FROM <%= entity.sync.master_entity.sql.qualified_table_name %> M " +
<%
  ref_index = 0
  db_attr.select{|a| a.reference?}.collect do |a|
      ref_index += 1
      if a.referenced_entity.abstract?
  -%>
<% a.referenced_entity.subtypes.select{|a| !a.abstract? }.each_with_index do |subtype, index| -%>
      " LEFT JOIN <%= subtype.sync.master_entity.sql.qualified_table_name %> R<%= ref_index %><%= index %> ON R<%= ref_index %><%= index %>.<%= data_module.sql.dialect.quote('ID') %> = M.<%=entity.sync.master_entity.attribute_by_name( a.primary_key? ? a.entity.root_entity.name : a.name ).sql.quoted_column_name %> " +
<% end -%>
<% else -%>
      " LEFT JOIN <%= a.referenced_entity.sync.master_entity.sql.qualified_table_name %> R<%= ref_index %> ON R<%= ref_index %>.<%= data_module.sql.dialect.quote('ID') %> = M.<%=entity.sync.master_entity.attribute_by_name( a.primary_key? ? a.entity.root_entity.name : a.name ).sql.quoted_column_name %> " +
<%
      end
  end
-%>
      "WHERE <%= criteria %> AND M.<%= data_module.sql.dialect.quote('DeletedAt') %> IS NULL";
     */
    throw new IllegalStateException( "Override getSqlToRetrieve<%= fn %>ListToUpdate() due to multiple recursive attributes." );
<% end -%>
  }

  @javax.annotation.Nonnull
  @java.lang.Override
  public String getSqlToRetrieve<%= fn %>ListToRemove( @javax.annotation.Nonnull final String mappingSourceCode )
  {
<% if recursive_attributes.size == 0 -%>
    return
      "SELECT M.[ID], M.<%= entity.sync.master_entity.attribute_by_name( entity.root_entity.name ).sql.quoted_column_name %> " +
      "FROM <%= entity.sync.master_entity.sql.qualified_table_name %> M " +
      "WHERE <%= criteria %> AND M.<%= data_module.sql.dialect.quote('DeletedAt') %> IS NOT NULL AND M.<%= entity.sync.master_entity.attribute_by_name( entity.root_entity.name ).sql.quoted_column_name %> IS NOT NULL";
<% elsif recursive_attributes.size == 1 -%>
    return
      "WITH <%= fn %>List([ID], <%= base_attr_select.gsub('M.','') %>, [MappingID], [MasterSynchronized], [MappingSource], [Level]) AS (\n" +
      "  SELECT M.[ID], <%= base_attr_select %>, M.[MappingID], M.[MasterSynchronized], M.[MappingSource], 0 " +
      "  FROM <%= entity.sync.master_entity.sql.qualified_table_name %> M " +
      "  WHERE M.<%= recursive_attributes[0].sql.quoted_column_name %> IS NULL " +
      "  UNION ALL " +
      "  SELECT M.[ID], <%= base_attr_select %>, M.[MappingID], M.[MasterSynchronized], M.[MappingSource], L.[Level] + 1 " +
      "  FROM <%= entity.sync.master_entity.sql.qualified_table_name %> M " +
      "  JOIN <%= fn %>List L ON L.[ID] = M.<%= recursive_attributes[0].sql.quoted_column_name %> " +
      "  WHERE M.<%= recursive_attributes[0].sql.quoted_column_name %> IS NOT NULL " +
      " )  " +
      " SELECT M.[ID], M.<%= entity.sync.master_entity.attribute_by_name( entity.name ).sql.quoted_column_name %> " +
      "  FROM <%= fn %>List M " +
      "  WHERE <%= criteria %>  AND M.<%= data_module.sql.dialect.quote('DeletedAt') %> IS NOT NULL AND M.<%= entity.sync.master_entity.attribute_by_name( entity.name ).sql.quoted_column_name %> IS NOT NULL" +
      "  ORDER BY M.Level DESC ";
<% else -%>
    /*
    return
      "SELECT M.<%= data_module.sql.dialect.quote('MappingID') %>, M.<%= entity.sync.master_entity.attribute_by_name( entity.name ).sql.quoted_column_name %> " +
      "FROM <%= entity.sync.master_entity.sql.qualified_table_name %> M " +
      "WHERE <%= criteria %> AND M.<%= data_module.sql.dialect.quote('DeletedAt') %> IS NOT NULL";
    */
    throw new IllegalStateException( "Override getSqlToRetrieve<%= fn %>ListToRemove() due to multiple recursive attributes." );
<% end -%>
  }

<% end -%>
}
