<%= banner("Data Module '#{data_module.name}'") %>
<% data_module.object_types.select{|object_type| !object_type.abstract?}.each do |object_type| %>
<%= banner("Foreign Keys for #{object_type.sql.qualified_table_name}") %>
<% object_type.sql.foreign_keys.each do |foreign_key| %>
IF  EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N'<%= foreign_key.qualified_foreign_key_name %>') AND parent_object_id = OBJECT_ID(N'<%= object_type.sql.qualified_table_name %>'))
  ALTER TABLE <%= object_type.sql.qualified_table_name %> DROP CONSTRAINT [<%= foreign_key.foreign_key_name %>]
GO
ALTER TABLE <%= object_type.sql.qualified_table_name %>
  WITH NOCHECK ADD CONSTRAINT [<%= foreign_key.foreign_key_name %>] FOREIGN KEY (<%= foreign_key.attribute_names.collect{|a| q(object_type.attribute_by_name(a).sql.column_name)}.join(', ') %>)
  REFERENCES <%= foreign_key.referenced_object_type.sql.qualified_table_name %> (<%= foreign_key.referenced_attribute_names.collect{|a| q(foreign_key.referenced_object_type.attribute_by_name(a).sql.column_name)}.join(', ')  %>)
<% if foreign_key.on_update != :no_action %>  ON UPDATE <%= Domgen::Sql::ForeignKey::ACTION_MAP[foreign_key.on_update] %><% end %>
<% if foreign_key.on_delete != :no_action %>  ON DELETE <%= Domgen::Sql::ForeignKey::ACTION_MAP[foreign_key.on_delete] %><% end %>
GO
ALTER TABLE <%= object_type.sql.qualified_table_name %> NOCHECK CONSTRAINT [<%= foreign_key.foreign_key_name %>]
GO
<%
  end
  if object_type.sql.constraints.size > 0 %><%=
    banner("Constraints for #{object_type.sql.qualified_table_name}")
%><%
      object_type.sql.constraints.each do |constraint|
%>
IF  EXISTS (SELECT * FROM sys.check_constraints WHERE object_id = OBJECT_ID(N'<%= constraint.qualified_constraint_name %>') AND parent_object_id = OBJECT_ID(N'<%= object_type.sql.qualified_table_name %>'))
  ALTER TABLE <%= object_type.sql.qualified_table_name %> DROP CONSTRAINT <%= constraint.constraint_name %>
GO
ALTER TABLE <%= object_type.sql.qualified_table_name %>
  WITH NOCHECK ADD CONSTRAINT <%= constraint.constraint_name %> CHECK ( <%= s(constraint.sql) %> )
GO
ALTER TABLE <%= object_type.sql.qualified_table_name %> NOCHECK CONSTRAINT [<%= constraint.constraint_name %>]
GO
<% constraint.tags.each_pair do |name, value| %>
EXEC sys.sp_addextendedproperty
  @name = N'<%= sql_extended_property_key(name) %>',
  @value = N'<%= value.strip %>',
  @level0type = N'SCHEMA', @level0name = <%= q(data_module.sql.schema) %>,
  @level1type = N'TABLE',  @level1name = <%= q(object_type.sql.table_name) %>,
  @level2type = N'CONSTRAINT',  @level2name = <%= q(constraint.constraint_name) %>;
GO
<% end %>
<%    end
   end
   if object_type.sql.function_constraints.size > 0 %><%=
    banner("Function Constraints for #{object_type.sql.qualified_table_name}")
%><%
    object_type.sql.function_constraints.each do |constraint|
%>
IF  EXISTS (SELECT * FROM sys.check_constraints WHERE object_id = OBJECT_ID(N'<%= constraint.qualified_constraint_name %>') AND parent_object_id = OBJECT_ID(N'<%= object_type.sql.qualified_table_name %>'))
  ALTER TABLE <%= object_type.sql.qualified_table_name %> DROP CONSTRAINT <%= constraint.constraint_name %>
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'<%= data_module.sql.schema %>.<%= s(object_type.name) %>_<%= s(constraint.name) %>') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
  DROP FUNCTION <%= data_module.sql.schema %>.<%= s(object_type.name) %>_<%= s(constraint.name) %>
GO
CREATE FUNCTION <%= data_module.sql.schema %>.<%= s(object_type.name) %>_<%= s(constraint.name) %>
(
<%= constraint.parameters.collect{|parameter_name| a = object_type.attribute_by_name(parameter_name); "  @#{a.sql.column_name} #{a.sql.sql_type}"}.join(",\n") %>
)
RETURNS BIT
AS
BEGIN
  DECLARE @Result BIT;
  SET @Result = 0;
  <%= constraint.common_table_expression %>
  SELECT @Result = 1 WHERE EXISTS (<%= constraint.positive_sql %>)
  RETURN @Result
END
GO
<% constraint.tags.each_pair do |name, value| %>
EXEC sys.sp_addextendedproperty
  @name = N'<%= sql_extended_property_key(name) %>',
  @value = N'<%= value.strip %>',
  @level0type = N'SCHEMA', @level0name = <%= q(data_module.sql.schema) %>,
  @level1type = N'FUNCTION',  @level1name = [<%= s(object_type.name) %>_<%= s(constraint.name) %>];
GO
<% end %>
ALTER TABLE <%= object_type.sql.qualified_table_name %>
  WITH NOCHECK ADD CONSTRAINT
  <%= constraint.constraint_name %>
  CHECK (<%= q(data_module.sql.schema) %>.<%= s(object_type.name) %>_<%= s(constraint.name) %>(<%= constraint.parameters.collect{|parameter_name| a = object_type.attribute_by_name(parameter_name); "  #{a.sql.column_name}"}.join(",") %>) = 1)
GO
ALTER TABLE <%= object_type.sql.qualified_table_name %> NOCHECK CONSTRAINT [<%= constraint.constraint_name %>]
<% constraint.tags.each_pair do |name, value| %>
EXEC sys.sp_addextendedproperty
  @name = N'<%= sql_extended_property_key(name) %>',
  @value = N'<%= value.strip %>',
  @level0type = N'SCHEMA', @level0name = <%= q(data_module.sql.schema) %>,
  @level1type = N'TABLE',  @level1name = <%= q(object_type.sql.table_name) %>,
  @level2type = N'CONSTRAINT',  @level2name = <%= q(constraint.constraint_name) %>;
GO
<% end %>
    <%
    end
   end
   if object_type.sql.triggers.size > 0 %><%=
    banner("Triggers for #{object_type.sql.qualified_table_name}")
%><%
      object_type.sql.triggers.each do |trigger|
%>
IF  EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'<%= trigger.qualified_trigger_name %>'))
  DROP TRIGGER <%= trigger.qualified_trigger_name %>
GO
CREATE TRIGGER <%= trigger.qualified_trigger_name %> ON <%= object_type.sql.qualified_table_name %>
<%
  if trigger.after && !trigger.after.empty?
%>  AFTER <%= trigger.after.collect{|a| a.to_s.upcase }.join(", ") %>
<%
  end
  if trigger.instead_of && !trigger.instead_of.empty?
%>  INSTEAD OF <%= trigger.instead_of.collect{|a| a.to_s.upcase }.join(", ") %>
<%
  end
%>AS
  DECLARE @RowsAffected INT
  SET @RowsAffected = @@ROWCOUNT
  --no need to continue on if no rows affected
  IF @RowsAffected = 0 RETURN

  SET NOCOUNT ON; -- to avoid the rowcount messages
  SET ROWCOUNT 0; -- in case the client has modified the rowcount
<%= trigger.sql %>
GO
<% trigger.tags.each_pair do |name, value| %>
EXEC sys.sp_addextendedproperty
  @name = N'<%= sql_extended_property_key(name) %>',
  @value = N'<%= value.strip %>',
  @level0type = N'SCHEMA', @level0name = <%= q(data_module.sql.schema) %>,
  @level1type = N'TABLE',  @level1name = <%= q(object_type.sql.table_name) %>,
  @level2type = N'TRIGGER',  @level2name = <%= q(trigger.trigger_name) %>;
GO
<% end %>
DISABLE TRIGGER <%= trigger.qualified_trigger_name %> ON <%= object_type.sql.qualified_table_name %>
GO    
<%    end
    end
  end
%>

IF EXISTS
  ( SELECT *
    FROM dbo.sysobjects
    WHERE id = OBJECT_ID(N'<%= data_module.sql.schema %>.spCheckConstraints') AND OBJECTPROPERTY(id, N'IsProcedure') = 1)
  DROP PROCEDURE <%= data_module.sql.schema %>.spCheckConstraints
GO

CREATE PROCEDURE <%= data_module.sql.schema %>.spCheckConstraints
AS
BEGIN
  SET NOCOUNT ON;

  DECLARE @FailedConstraintChecks TABLE
(
    SchemaName VARCHAR(500),
    TableName VARCHAR(500),
    ConstraintName VARCHAR(500)
  )
<% data_module.object_types.select{|object_type| !object_type.abstract?}.each do |object_type| %>
<%
   constraints = object_type.sql.constraints + object_type.sql.function_constraints
   constraints.select{|constraint| constraint.invariant?}.each do |constraint| %>
  BEGIN TRY
    -- Consider using DBCC CHECKCONSTRAINTS here instead?
    ALTER TABLE <%= object_type.sql.qualified_table_name %> WITH CHECK CHECK CONSTRAINT [<%= constraint.constraint_name %>]
  END TRY
  BEGIN CATCH
    INSERT INTO @FailedConstraintChecks(SchemaName, TableName, ConstraintName)
      VALUES ('<%= data_module.sql.schema %>','<%= object_type.sql.table_name %>','<%= constraint.constraint_name %>')
  END CATCH
<%
   end
  end
%>
  SELECT * FROM @FailedConstraintChecks
END
GO
