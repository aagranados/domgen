/* DO NOT EDIT: File is autogenerated */
<% if !data_module.sql.default_schema? %>
IF EXISTS ( SELECT * FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME = '<%= data_module.sql.schema %>')
  DROP SCHEMA <%= q(data_module.sql.schema) %>
GO
CREATE SCHEMA <%= q(data_module.sql.schema) %>
GO
<% data_module.tags.each_pair do |name, value| %>
EXEC sys.sp_addextendedproperty
  @name = N'<%= sql_extended_property_key(name) %>',
  @value = N'<%= value.strip %>',
  @level0type = N'SCHEMA', @level0name = <%= q(data_module.sql.schema) %>
GO
<% end %>
<% end %>
<%= banner("DDL for Data Module '#{data_module.name}'") %>
<% data_module.object_types.select{|object_type| !object_type.abstract?}.each do |object_type| %>
<% if object_type.sql.partition_scheme %>
IF CONVERT(VARCHAR,SERVERPROPERTY('Edition')) LIKE 'Enterprise Edition%'
BEGIN

CREATE TABLE <%= object_type.sql.qualified_table_name %>(
<% object_type.attributes.select {|a| a.persistent?}.each do |a|
%>  <%= q(a.sql.column_name) %> <%= a.sql.sql_type %> <%= a.sql.identity? ? 'IDENTITY(1,1) ' : '' %><%= a.sql.sparse? ? 'SPARSE ' : ''%><%= a.nullable? ? '': 'NOT '%>NULL,
<% end
%>
    CONSTRAINT PK_<%= object_type.name %> PRIMARY KEY <%= (object_type.sql.indexes.select{|i| i.cluster?}.size == 0) ? '' : 'NON' %>CLUSTERED (<%= q(object_type.primary_key.sql.column_name) %> ASC) ON [PRIMARY]
) ON <%= object_type.sql.partition_scheme %>

END
ELSE
BEGIN
<% end %>

CREATE TABLE <%= object_type.sql.qualified_table_name %>(
<% object_type.attributes.select {|a| a.persistent?}.each do |a|
%>  <%= q(a.sql.column_name) %> <%= a.sql.sql_type %> <%= a.sql.identity? ? 'IDENTITY(1,1) ' : '' %><%= a.sql.sparse? ? 'SPARSE ' : ''%><%= a.nullable? ? '': 'NOT '%>NULL,
<% end
%>  CONSTRAINT PK_<%= object_type.name %> PRIMARY KEY <%= (object_type.sql.indexes.select{|i| i.cluster?}.size == 0) ? '' : 'NON' %>CLUSTERED (<%= q(object_type.primary_key.sql.column_name) %> ASC)
)

<% if object_type.sql.partition_scheme %>
END
<% end %>
GO
<% object_type.tags.each_pair do |name, value| %>
EXEC sys.sp_addextendedproperty
  @name = N'<%= sql_extended_property_key(name) %>',
  @value = N'<%= value.strip %>',
  @level0type = N'SCHEMA', @level0name = <%= q(data_module.sql.schema) %>,
  @level1type = N'TABLE',  @level1name = <%= q(object_type.sql.table_name) %>;
GO
<% end %>
<% object_type.attributes.select {|a| a.persistent? && !a.tags.empty?}.each do |a| %>
<% a.tags.each_pair do |name, value| %>
EXEC sys.sp_addextendedproperty
  @name = N'<%= sql_extended_property_key(name) %>',
  @value = N'<%= value.strip %>',
  @level0type = N'SCHEMA', @level0name = <%= q(data_module.sql.schema) %>,
  @level1type = N'TABLE',  @level1name = <%= q(object_type.sql.table_name) %>,
  @level2type = N'COLUMN', @level2name = <%= q(a.sql.column_name) %>;
GO
<% end %>
<% end %>
<% if !object_type.sql.force_overflow_for_large_objects.nil? %>
EXEC sp_tableoption '<%= q(data_module.sql.schema) %>.<%= q(object_type.sql.table_name) %>', 'large value types out of row', <%= object_type.sql.force_overflow_for_large_objects ? '1' : '0' %>
<% end %>
<% object_type.attributes.select {|a| a.persistent? && !a.sql.default_value.nil?}.each do |a| %>
ALTER TABLE <%= object_type.sql.qualified_table_name %> ADD DEFAULT (<%= quote_value(a.sql.default_value) %>) FOR <%= q(a.sql.column_name) %>
GO
<% end %>
-- Set NUMERIC_ROUNDABORT so filtered indexes can be created
SET NUMERIC_ROUNDABORT OFF
GO
<% object_type.sql.indexes.each do |index| %>
CREATE <%= index.unique? ? 'UNIQUE ' : '' %><%= index.cluster? ? '' : 'NON' %>CLUSTERED INDEX [<%= index.name %>] ON <%= object_type.sql.qualified_table_name %>
(<%= index.attribute_names.collect {|a| "\n  #{q(object_type.attribute_by_name(a).sql.column_name)} ASC" }.join(",") %>
)<% if !index.include_attribute_names.nil? %> INCLUDE ( <%= index.include_attribute_names.collect {|a| q(object_type.attribute_by_name(a).sql.column_name) }.join(",") %> )<% end %>
<% if index.filter %>WHERE <%= index.filter %><% end %>
<%= index.unique? ? 'ON [PRIMARY]' : '' %>
GO
<% index.tags.each_pair do |name, value| %>
EXEC sys.sp_addextendedproperty
  @name = N'<%= sql_extended_property_key(name) %>',
  @value = N'<%= value.strip %>',
  @level0type = N'SCHEMA', @level0name = <%= q(data_module.sql.schema) %>,
  @level1type = N'TABLE',  @level1name = <%= q(object_type.sql.table_name) %>,
  @level2type = N'INDEX',  @level2name = <%= q(index.name) %>;
GO
<% end %>

<% end %>
<% object_type.sql.foreign_keys.each do |foreign_key| %>
ALTER TABLE <%= object_type.sql.qualified_table_name %>
  ADD CONSTRAINT [FK_<%= object_type.name %>_<%= foreign_key.name %>] FOREIGN KEY (<%= foreign_key.attribute_names.collect{|a| q(object_type.attribute_by_name(a).sql.column_name)}.join(', ') %>)
  REFERENCES <%= foreign_key.referenced_object_type.sql.qualified_table_name %> (<%= foreign_key.referenced_attribute_names.collect{|a| q(foreign_key.referenced_object_type.attribute_by_name(a).sql.column_name)}.join(', ')  %>)
<% if foreign_key.on_update != :no_action %>  ON UPDATE <%= Domgen::Sql::ForeignKey::ACTION_MAP[foreign_key.on_update] %><% end %>
<% if foreign_key.on_delete != :no_action %>  ON DELETE <%= Domgen::Sql::ForeignKey::ACTION_MAP[foreign_key.on_delete] %><% end %>
GO
<%
  end
  if object_type.sql.constraints.size > 0 %><%=
    banner("Constraints for #{object_type.sql.qualified_table_name}")
%><%
      object_type.sql.constraints.each do |constraint|
%>
ALTER TABLE <%= object_type.sql.qualified_table_name %>
  ADD CONSTRAINT <%= constraint.constraint_name %> CHECK ( <%= s(constraint.sql) %> )
GO
<% constraint.tags.each_pair do |name, value| %>
EXEC sys.sp_addextendedproperty
  @name = N'<%= sql_extended_property_key(name) %>',
  @value = N'<%= value.strip %>',
  @level0type = N'SCHEMA', @level0name = <%= q(data_module.sql.schema) %>,
  @level1type = N'TABLE',  @level1name = <%= q(object_type.sql.table_name) %>,
  @level2type = N'CONSTRAINT',  @level2name = <%= q(constraint.constraint_name) %>;
GO
<% end %>
<%    end
   end
   if object_type.sql.function_constraints.size > 0 %><%=
    banner("Function Constraints for #{object_type.sql.qualified_table_name}")
%><%
    object_type.sql.function_constraints.each do |constraint|
%>
CREATE FUNCTION <%= data_module.sql.schema %>.<%= s(object_type.name) %>_<%= s(constraint.name) %>
(
<%= constraint.parameters.collect{|parameter_name| a = object_type.attribute_by_name(parameter_name); "  @#{a.sql.column_name} #{a.sql.sql_type}"}.join(",\n") %>
)
RETURNS BIT
AS
BEGIN
  DECLARE @Result BIT;
  <%= constraint.common_table_expression %>
  SELECT @Result = CONVERT(BIT,(SELECT COUNT(*) FROM (<%= constraint.positive_sql %>) F))
  RETURN @Result
END
GO
<% constraint.tags.each_pair do |name, value| %>
EXEC sys.sp_addextendedproperty
  @name = N'<%= sql_extended_property_key(name) %>',
  @value = N'<%= value.strip %>',
  @level0type = N'SCHEMA', @level0name = <%= q(data_module.sql.schema) %>,
  @level1type = N'FUNCTION',  @level1name = [<%= s(object_type.name) %>_<%= s(constraint.name) %>];
GO
<% end %>
ALTER TABLE <%= object_type.sql.qualified_table_name %>
  WITH CHECK ADD CONSTRAINT
  <%= constraint.constraint_name %>
  CHECK (<%= q(data_module.sql.schema) %>.<%= s(object_type.name) %>_<%= s(constraint.name) %>(<%= constraint.parameters.collect{|parameter_name| a = object_type.attribute_by_name(parameter_name); "  #{a.sql.column_name}"}.join(",") %>) = 1)
GO
<% constraint.tags.each_pair do |name, value| %>
EXEC sys.sp_addextendedproperty
  @name = N'<%= sql_extended_property_key(name) %>',
  @value = N'<%= value.strip %>',
  @level0type = N'SCHEMA', @level0name = <%= q(data_module.sql.schema) %>,
  @level1type = N'TABLE',  @level1name = <%= q(object_type.sql.table_name) %>,
  @level2type = N'CONSTRAINT',  @level2name = <%= q(constraint.constraint_name) %>;
GO
<% end %>
    <%
    end
   end
   if object_type.sql.triggers.size > 0 %><%=
    banner("Triggers for #{object_type.sql.qualified_table_name}")
%><%
      object_type.sql.triggers.each do |trigger|
%>
CREATE TRIGGER <%= trigger.qualified_trigger_name %> ON <%= object_type.sql.qualified_table_name %>
<% if trigger.after == :both %>AFTER INSERT, UPDATE<% elsif trigger.after == :insert %>AFTER INSERT<% elsif trigger.after == :update %>AFTER UPDATE<% end %>
AS
  DECLARE @RowsAffected INT
  SET @RowsAffected = @@rowcount
  --no need to continue on if no rows affected
  IF @RowsAffected = 0 RETURN

  SET NOCOUNT ON; -- to avoid the rowcount messages
  SET ROWCOUNT 0; -- in case the client has modified the rowcount
<%= trigger.sql %>
GO
<% trigger.tags.each_pair do |name, value| %>
EXEC sys.sp_addextendedproperty
  @name = N'<%= sql_extended_property_key(name) %>',
  @value = N'<%= value.strip %>',
  @level0type = N'SCHEMA', @level0name = <%= q(data_module.sql.schema) %>,
  @level1type = N'TABLE',  @level1name = <%= q(object_type.sql.table_name) %>,
  @level2type = N'TRIGGER',  @level2name = <%= q(trigger.trigger_name) %>;
GO
<% end %>
<%    end
    end
  end
%>
