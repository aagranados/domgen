/* DO NOT EDIT: File is autogenerated */
package <%= object_type.schema.java.package %>.persist;
<%
set_iris_mode

fqn = j_classname(object_type.java.fully_qualified_name)
%>

@javax.annotation.Generated( "Domgen" )
@SuppressWarnings( { "UnusedDeclaration" } )
public final class <%= object_type.java.classname %>PersistPeer
   extends iris.persist.DatabasePeer
{
<%  if object_type.abstract?
%>  public <%= object_type.java.classname %>PersistPeer()
  {
    setCached( false );
  }
<% end
%>  protected Class<<%= fqn %>> getPersistentClass()
  {
    return <%= fqn %>.class;
  }

  public java.util.List<java.util.Map<String, Object>> restoreDataSet( final java.util.Map<String,Object> criteria, final java.sql.Connection connection )
      throws iris.beans.MissingBeanException
  {
    final java.util.List<java.util.Map<String, Object>> list = super.restoreDataSet( criteria, connection );
    final iris.beans.store.DataStore dataStore = iris.beans.BeanFactory.getManager().getDataStore();
    for ( final java.util.Map<String, Object> resultData : list )
    {
      dataStore.registerObjectData( getPersistentClass(), resultData );
    }
    return list;
  }

  protected String handleCriterion( final java.util.Map<String,Object> criteria )
  {
    final StringBuilder sb = new StringBuilder();
<% object_type.attributes.select {|a| a.persistent? && !a.iris.runtime_managed?}.each do |attribute|
     upper_name = uppercase_constantize(attribute.name)
%>    if ( criteria.containsKey( <%= fqn %>.COLUMN_<%= upper_name %> ) )
    {
      prepareAppend( sb );
      sb.append( <%= fqn %>.COLUMN_<%= upper_name %> );
      columnCriterionMatch( sb, criteria.get( <%= fqn %>.COLUMN_<%= upper_name %> ) );
    }
<%
  end
  object_type.iris.criteria.select{|c| !c.code_based?}.each do |criterion|
%>    if ( criteria.containsKey( <%= fqn %>.QUERY_<%= uppercase_constantize(criterion.name) %> ) )
    {
      final String[] values = prepareSQLArray( criteria.get( <%= fqn %>.QUERY_<%= uppercase_constantize(criterion.name) %> ) );
      final java.text.MessageFormat format = new java.text.MessageFormat( "<%= criterion.sql %>" );
      final String sql = format.format( values );
      prepareAppend( sb );
      sb.append( sql );
    }
<% end
  object_type.iris.criteria.select{|c| c.code_based?}.each do |criterion|
%>    if ( criteria.containsKey( <%= fqn %>.QUERY_<%= uppercase_constantize(criterion.name) %> ) )
    {
      prepareAppend( sb );
      sb.append( <%= object_type.java.classname %>PersistHelper.handle<%= criterion.name %>Criterion( (<%= criterion.java_parameter_type %>)criteria.get( <%= fqn %>.QUERY_<%= uppercase_constantize(criterion.name) %> ) ) );
    }
<% end
%>    return sb.toString();
  }

  protected String handleSelection()
  {
<%
  if object_type.abstract?
%>    throw new UnsupportedOperationException( "getTableName() called on abstract object type <%= object_type.name %>" );
<%
  else
%>    final StringBuffer sb = new StringBuffer();

    sb.append( iris.busobj.BusObjEntry.BATCH_ID );
    sb.append( COMMA );
    sb.append( iris.busobj.BusObjEntry.TO_DATE );
<% object_type.attributes.select {|a| a.persistent? && !a.iris.runtime_managed?}.each do |attribute| 
%>    sb.append( COMMA );
    sb.append( <%= fqn %>.COLUMN_<%= uppercase_constantize(attribute.name) %> );
<% end %>
    return sb.toString();
<% end %>  }

  protected String getTableName()
  {
<%
  if object_type.abstract?
%>    throw new UnsupportedOperationException( "getTableName() called on abstract object type <%= object_type.name %>" );
<%
  else
%>    return <%= fqn %>.TABLE_NAME;
<% end %>  }

  protected String getRemoveSql( final iris.beans.AbstractBean persistent )
  {
<%
  if object_type.abstract?
%>    throw new UnsupportedOperationException( "Remove of abstract object type <%= object_type.name %> is not supported" );
<%
  else
%>    final <%= fqn %> value = (<%= fqn %>)persistent;
    final iris.busobj.BusObjEntry entry = iris.busobj.BusObjEntry.getEntry( value );
    final StringBuilder sb = new StringBuilder();
    sb.append( UPDATE );
    sb.append( quote( <%= fqn %>.TABLE_NAME ) );
    sb.append( SET );
    sb.append( iris.busobj.BusObjEntry.TO_DATE );
    sb.append( EQUALS );
    sb.append( prepareSQL( entry.getToDate() ) );
    sb.append( COMMA );
    sb.append( iris.busobj.BusObjEntry.BATCH_ID );
    sb.append( EQUALS );
    sb.append( prepareSQL( entry.getBatchID() ) );
    sb.append( WHERE );
    sb.append( ID );
    sb.append( EQUALS );
    sb.append( prepareSQL( value.get<%= object_type.primary_key.java.field_name %>() ) );
    return sb.toString();
<% end %>  }

  protected String getUpdateSql( final iris.beans.AbstractBean persistent )
  {
<%
  if object_type.abstract?
%>    throw new UnsupportedOperationException( "Update of abstract object type <%= object_type.name %> is not supported" );
<%
  else
    mutable_attributes = object_type.attributes.select {|a| !a.primary_key? && !a.immutable? && a.persistent? && !a.iris.runtime_managed?}
if mutable_attributes.size == 0
%>    return null;
<% else %>
    <%= object_type.schema.java.package %>.<%= object_type.schema.name %>Validator.validate( persistent );
    final <%= fqn %> value = (<%= fqn %>)persistent;

    final StringBuilder sb = new StringBuilder();
    sb.append( UPDATE );
    sb.append( <%= fqn %>.TABLE_NAME );
    sb.append( SET );
    sb.append( quote( iris.busobj.BusObjEntry.BATCH_ID ) );
    sb.append( EQUALS );
    sb.append( prepareSQL( iris.busobj.BusObjEntry.getEntry( persistent ).getBatchID() ) );
<% mutable_attributes.each do |attribute|
  name = attribute.reference? ? attribute.referencing_link_name : attribute.java.field_name
  suffix = (attribute.attribute_type == :i_enum) ? ".getValue()" : ""
%>    sb.append( COMMA );
    sb.append( quote( <%= fqn %>.COLUMN_<%= uppercase_constantize(attribute.name) %> ) );
    sb.append( EQUALS );
    sb.append( prepareSQL( value.get<%= name %>()<%= suffix %> ) );
<% end
%>    sb.append( WHERE );
    sb.append( ID );
    sb.append( EQUALS );
    sb.append( prepareSQL( value.get<%= object_type.primary_key.java.field_name %>() ) );
    return sb.toString();
<%
  end
 end
%>  }

  protected String getInsertSql( final iris.beans.AbstractBean persistent )
  {
<%
  if object_type.abstract?
%>    throw new UnsupportedOperationException( "Insert of abstract object type <%= object_type.name %> is not supported" );
<%
  else
%>    <%= object_type.schema.java.package %>.<%= object_type.schema.name %>Validator.validate( persistent );
    final <%= fqn %> value = (<%= fqn %>)persistent;
    final iris.busobj.BusObjEntry entry = iris.busobj.BusObjEntry.getEntry( value );
    final StringBuffer sb = new StringBuffer();
    sb.append( INSERT_INTO );
    sb.append( <%= fqn %>.TABLE_NAME );
    sb.append( " (" );
    sb.append( quote( iris.busobj.BusObjEntry.BATCH_ID ) );
    sb.append( COMMA );
    sb.append( quote( iris.busobj.BusObjEntry.TO_DATE ) );
<% object_type.attributes.select {|a| a.persistent? && !a.iris.runtime_managed?}.each do |attribute|
%>    sb.append( COMMA );
    sb.append( quote( <%= fqn %>.COLUMN_<%= uppercase_constantize(attribute.name) %> ) );
<% end %>
    sb.append( VALUES );
    sb.append( prepareSQL( entry.getBatchID() ) );
    sb.append( COMMA );
    sb.append( prepareSQL( entry.getToDate() ) );
<% object_type.attributes.select {|a| a.persistent? && !a.iris.runtime_managed?}.each do |attribute|
  name = attribute.reference? ? attribute.referencing_link_name : attribute.java.field_name
  suffix = (attribute.attribute_type == :i_enum) ? ".getValue()" : ""
%>    sb.append( COMMA );
    sb.append( prepareSQL( value.get<%= name %>()<%= suffix %> ) );
<% end
%>    sb.append( ")" );
    return sb.toString();
<% end %>  }

  protected void prepareQueryTail( final StringBuilder sb, final java.util.Map<String,Object> criteria )
  {
    boolean order = false;
    if ( null != criteria && criteria.containsKey( INCLUDE_DELETED ) )
    {
      order = true;
    }
    else if ( null != criteria && criteria.containsKey( iris.busobj.BusObjEntry.BATCH_ID ) )
    {
      prepareAppend( sb );
      sb.append( iris.busobj.BusObjEntry.BATCH_ID );
      sb.append( EQUALS );
      sb.append( criteria.get( iris.busobj.BusObjEntry.BATCH_ID ) );
    }
    else
    {
      prepareAppend( sb );
      sb.append( getCurrentTimeCriteria() );
      order = true;
    }

    if ( order )
    {
      if ( null != criteria && !criteria.containsKey( NO_ORDER_BY ) )
      {
        final String orderBy = getOrderBy( criteria, null );
        sb.append( orderBy );
        if ( !"".equals( orderBy ) && criteria.containsKey( ORDER_BY_DESC ) )
        {
          sb.append( DESC );
        }
      }
    }
  }

  @Override
  protected String getDeclarations( final java.util.Map<String, Object> criteria )
  {
    return <%= (object_type.name == :SpecificTask) ? "SpecificTaskPersistHelper.getDeclarations( criteria )" : "\"\"" %>;
  }

<%  if !object_type.final?
  concrete_subclasses = []
  types = [object_type]
  while !types.empty?
     ot = types.pop
     concrete_subclasses << ot unless ot.abstract?
     ot.direct_subtypes.each do |sc|
       types << sc
     end
  end
  attributes = {}
  concrete_subclasses.each do |sc|
    sc.attributes.select{|a| a.persistent? && !a.iris.runtime_managed?}.each do |attribute|
      attributes[attribute.name] = attribute unless attributes[attribute.name]    
    end
  end
%>  public String getRestoreSetSql( java.util.Map<String, Object> criteria )
  {
    if ( null == criteria )
    {
      criteria = new java.util.HashMap<String, Object>();
    }
    criteria.put( NO_ORDER_BY, "true" );
    final String whereClause = getWhereClause( criteria );

    final StringBuffer sb = new StringBuffer( getDeclarations( criteria ) );
<% concrete_subclasses.each_with_index do |sc,index|
 if 0 != index %>    sb.append( UNION );
<% end
%>    sb.append( SELECT );
    sb.append( <%= object_type.schema.java.package %>.<%= object_type.schema.name %>Codec.<%= uppercase_constantize(sc.name) %>_TYPE_CODE );
    sb.append( AS );
    sb.append( quote( <%= object_type.schema.java.package %>.<%= object_type.schema.name %>Codec.TYPECODE ) );
    sb.append( COMMA );
    sb.append( quote( iris.busobj.BusObjEntry.BATCH_ID ) );
    sb.append( COMMA );
    sb.append( quote( iris.busobj.BusObjEntry.TO_DATE ) );
<% attributes.values.each do |attribute|
%>    sb.append( COMMA );
<% if sc.attribute_exists?(attribute.name)
%>    sb.append( quote( <%= j_classname(sc.java.fully_qualified_name) %>.COLUMN_<%= uppercase_constantize(attribute.name) %> ) );
<% else
%>    sb.append( <%= (attribute.attribute_type == :integer) ? 0 : "NULL" %> );
    sb.append( AS );
    sb.append( quote( <%= j_classname(attribute.object_type.java.fully_qualified_name) %>.COLUMN_<%= uppercase_constantize(attribute.name) %> ) );
<%
   end
 end
%>    sb.append( FROM );
    sb.append( quote( <%= j_classname(sc.java.fully_qualified_name) %>.TABLE_NAME ) );
    if ( whereClause.length() > 0 )
    {
      sb.append( WHERE );
      sb.append( whereClause );
    }
<% end %>    
    return sb.toString();
  }
<% end %>}
