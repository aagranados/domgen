/* DO NOT EDIT: File is autogenerated */
package <%= schema.java.package %>.visitor;

import iris.model.visitor.traversers.FilterDelegate;

@javax.annotation.Generated( "Domgen" )
public class ChainFilter
   implements Filter
{
   private final java.util.List<Filter> _filters = new java.util.ArrayList<Filter>();

   public void addFilter( final Filter filter )
   {
      if( !_filters.contains( filter ) )
      {
         _filters.add( filter );
      }
   }

   public void removeFilter( final Filter filter )
   {
      _filters.remove( filter );
   }

   public final java.util.List<Filter> getFilterList()
   {
      return _filters;
   }

   private Filter[] getFilters()
   {
     return _filters.toArray( new Filter[ _filters.size() ] );
   }

   public int acceptBean( final iris.beans.AbstractBean bean,
                          final FilterDelegate delegate,
                          final String linkerAttributeID,
                          final iris.beans.AbstractBean linker )
   {
      final Filter[] filters = getFilters();
      int result = ACCEPT;
      for ( final Filter filter : filters )
      {
         final int intermediateResult = filter.acceptBean( bean, delegate, linkerAttributeID, linker );
         result = mergeResult(result, intermediateResult);
         if( result == REJECT )
         {
            return REJECT;
         }
      }
      return result;
   }

   public int acceptDummy( final iris.beans.DummyBean dummy,
                           final FilterDelegate delegate,
                           final String linkerAttributeID,
                           final iris.beans.AbstractBean linker )
   {
      final Filter[] filters = getFilters();
      int result = ACCEPT;
      for ( final Filter filter : filters )
      {
         final int intermediateResult = filter.acceptDummy( dummy, delegate, linkerAttributeID, linker );
         result = mergeResult(result, intermediateResult);
         if( result == REJECT )
         {
            return REJECT;
         }
      }
      return result;
   }

   public int acceptNotDeployedNode( final iris.beans.NotDeployedNode bean,
                                     final FilterDelegate delegate,
                                     final String linkerAttributeID,
                                     final iris.beans.AbstractBean linker )
   {
      final Filter[] filters = getFilters();
      int result = ACCEPT;
      for ( final Filter filter : filters )
      {
         final int intermediateResult = filter.acceptNotDeployedNode( bean, delegate, linkerAttributeID, linker );
         result = mergeResult(result, intermediateResult);
         if( result == REJECT )
         {
            return REJECT;
         }
      }
      return result;
   }
<% schema.object_types.select{|o|!o.abstract?}.each do |object_type|
   name = object_type.name
   type = object_type.iris.classname
%>
   public int accept<%= name %>( final <%= type %> value, final FilterDelegate delegate, final String linkerAttributeID, final iris.beans.AbstractBean linker )
   {
      final Filter[] filters = getFilters();
      int result = ACCEPT;
      for ( final Filter filter : filters )
      {
         final int intermediateResult = filter.accept<%= name %>( value, delegate, linkerAttributeID, linker );
         result = mergeResult(result, intermediateResult);
         if( result == REJECT )
         {
            return REJECT;
         }
      }
      return result;
   }
<% end %>

   private static int mergeResult( final int result1, final int result2 )
   {
      return result1 & result2;
   }
}
