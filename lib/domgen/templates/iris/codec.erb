/* DO NOT EDIT: File is autogenerated */
package <%= schema.java.package %>;
<% set_iris_mode %>

@javax.annotation.Generated( "Domgen" )
@SuppressWarnings( { "UnusedDeclaration" } )
public class <%= schema.name %>Codec
{
   public static final String TYPECODE = "OBJECT_TYPECODE";

  /* Type Codes */
<% schema.object_types.select{|o|!o.abstract? && o.iris.generate? }.each_with_index do |object_type, index|
%>  public static final byte <%= uppercase_constantize(object_type.name) %>_TYPE_CODE = (byte)<%= index + 1 %>;
<% end %>

  /* Attr Masks */
<% schema.object_types.select{|o|!o.abstract? && o.iris.generate? }.each_with_index do |object_type, index|
%>  public static final int <%= uppercase_constantize(object_type.name) %>_CLIENT_TO_SERVER_ATTR_MASK = <%= object_type.attributes.select{|a| a.iris.client_side? && a.persistent? && !a.iris.runtime_managed? }.collect{|a| "#{j_classname(a.object_type.java.classname)}.#{uppercase_constantize(a.java.field_name)}_ATTR_ID" }.join(" | ") %>;
  static final int <%= uppercase_constantize(object_type.name) %>_SERVER_TO_SERVER_ATTR_MASK = <%= object_type.attributes.select{|a| a.persistent? && !a.iris.runtime_managed? }.collect{|a| "#{j_classname(a.object_type.java.classname)}.#{uppercase_constantize(a.java.field_name)}_ATTR_ID" }.join(" | ") %>;
<% end %>

  private static final Class<?>[] CLASSES_FOR_TYPE_CODE = {
    null,
    <%= schema.object_types.select{|o|!o.abstract? && o.iris.generate?}.collect{|o|"#{j_classname(o.java.classname)}.class"}.join(",\n    ") %>
  };

  private static final int[] SERVER_TO_SERVER_ATTR_MASK_FOR_TYPE_CODE = {
    0,
    <%= schema.object_types.select{|o|!o.abstract? && o.iris.generate?}.collect{|o|"#{uppercase_constantize(o.name)}_SERVER_TO_SERVER_ATTR_MASK"}.join(",\n    ") %>
  };


  public static <T extends iris.beans.AbstractBean> Class<T> getActualType( final Class<T> clazz, final java.util.Map<String, Object> data )
  {
    final Integer typeCode = (Integer) data.get( TYPECODE );
    if ( null != typeCode )
    {
      return iris.util.StaticLoophole.cast( getClassForTypeCode( typeCode ) );
    }
    else
    {
      return clazz;
    }
  }

  public static Class<?> getClassForTypeCode( final int typeCode )
  {
    return CLASSES_FOR_TYPE_CODE[typeCode];
  }

  public static int getTypeCodeForClass( final Class<?> type )
  {
    for( int i = 0; i < CLASSES_FOR_TYPE_CODE.length; i++ )
    {
      if( CLASSES_FOR_TYPE_CODE[i] == type )
      {
        return i;
      }
    }
    return -1;
  }

  public static java.util.Map<String, Object> readBean( final byte[] input, final boolean includeToDate )
    throws java.io.IOException, ClassNotFoundException
  {
    return readBean( new java.io.ObjectInputStream( new java.io.ByteArrayInputStream( input ) ), includeToDate );
  }

  private static java.util.Map<String, Object> readBean( final java.io.ObjectInput input, final boolean includeToDate )
     throws java.io.IOException, ClassNotFoundException
  {
      final java.util.Map<String, Object> data = new java.util.HashMap<String, Object>();

      final int typeCode = input.readByte();
      data.put( TYPECODE, typeCode );

      final Object primaryKey = input.readObject();
      data.put( iris.persist.DatabasePeer.ID, primaryKey );

      final int attributesMask;
      if ( includeToDate )
      {
         attributesMask = SERVER_TO_SERVER_ATTR_MASK_FOR_TYPE_CODE[typeCode];
      }
      else
      {
         attributesMask = input.readInt();
      }
      if ( includeToDate )
      {
         final long to = input.readLong();
         if ( 0 != to )
         {
            data.put( iris.busobj.BusObjEntry.TO_DATE, new java.sql.Timestamp( to ) );
         }
      }

    <% schema.object_types.select{|o|!o.abstract? && o.iris.generate? }.each_with_index do |object_type, index|
%>if( <%= uppercase_constantize(object_type.name) %>_TYPE_CODE == typeCode )
      {
        read<%= object_type.name %>IntoMap( input, data, attributesMask );
      }
      else <% end %>
      {
        throw new IllegalStateException("Unknown typeCode " + typeCode );
      }
      return data;
   }

  public static byte[] writeBean( final iris.beans.AbstractBean bean, final int attributesMask, final boolean includeToDate )
    throws java.io.IOException
  {
    final java.io.ByteArrayOutputStream output = new java.io.ByteArrayOutputStream();
    final java.io.ObjectOutputStream objectOutputStream = new java.io.ObjectOutputStream( output );
    try
    {
      <% schema.object_types.reverse.select{|o|!o.abstract? && o.iris.generate? }.each do |object_type|
     name = object_type.name
     type = j_classname(object_type.java.fully_qualified_name)
  %>if( <%= type %>.class.isInstance( bean ) )
      {
        write<%= object_type.name %>To( (<%= type %>)bean, objectOutputStream, includeToDate, attributesMask );
      }
      else <% end %>
      {
        final String message = "Unable to validate bean: " + bean;
        throw new IllegalArgumentException( message );
      }
    }
    catch ( final RuntimeException e )
    {
      iris.util.debug.IDebug.error( "Failed to write bean: " + bean + " using mask " + attributesMask );
      throw e;
    }
    return output.toByteArray();
  }

<% schema.object_types.select{|o|!o.abstract? && o.iris.generate? }.each do |object_type|
%>
  private static void read<%= object_type.name %>IntoMap( final java.io.ObjectInput input,
                           final java.util.Map<String, Object> data,
                           final int attributesMask )
      throws java.io.IOException, ClassNotFoundException
   {
<% object_type.attributes.select{|a| !a.primary_key? && !a.iris.runtime_managed? && a.persistent? && a.iris.client_side? }.each do |attribute|
     name = attribute.java.field_name
     attr_type = attribute.reference? ? attribute.referenced_object.primary_key.attribute_type : attribute.attribute_type
%>
      if( 0 != ( <%= j_classname(object_type.java.classname) %>.<%= uppercase_constantize(name) %>_ATTR_ID & attributesMask ) )
      {
        {
<% if attr_type == :integer %>          final Object value = input.readInt();
<% elsif attr_type == :i_enum %>          final Object value = ( (int)input.readByte() );
<% elsif attr_type == :boolean %>          final Object value = input.readBoolean();
<% elsif attr_type == :string || attr_type == :s_enum %>          final String string = input.readUTF();
          final Object value = "\0".equals( string ) ? null : string;
<% elsif attr_type == :datetime %>          final long time = input.readLong();
          final Object value = ( Long.MAX_VALUE == time ) ? null : new java.sql.Timestamp( time );
<% else %>          throw new IllegalStateException( "Unknown attribute type transmitted <%= attr_type %>" );<% end %>
          data.put( <%= j_classname(object_type.java.classname) %>.COLUMN_<%= uppercase_constantize(name) %>, value );
        }
      }
<% end %>
   }

  private static void write<%= object_type.name %>To( final <%= j_classname(object_type.java.classname) %> bean, final java.io.ObjectOutput output, final boolean includeToDate, final int attributesMask )
     throws java.io.IOException
  {
    output.writeByte( <%= uppercase_constantize(object_type.name) %>_TYPE_CODE );
    output.writeObject( bean.get<%= object_type.primary_key.name %>() );

    if ( includeToDate )
    {
      final iris.busobj.BusObjEntry entry = iris.busobj.BusObjEntry.getEntry( bean );
      if ( entry.getToDate() == null )
      {
        output.writeLong( 0 );
      }
      else
      {
        output.writeLong( entry.getToDate().getTime() );
      }
    }
    else
    {
      output.writeInt( attributesMask );
    }
<% object_type.attributes.select{|a| !a.primary_key? && !a.iris.runtime_managed? && a.persistent? && a.iris.client_side? }.each do |attribute|
     name = attribute.reference? ? attribute.referencing_link_name : attribute.java.field_name
     attr_type = attribute.reference? ? attribute.referenced_object.primary_key.attribute_type : attribute.attribute_type
     is_primitive = attribute.reference? ? attribute.referenced_object.primary_key.java.primitive? : attribute.java.primitive?
%>
      if( 0 != (<%= j_classname(object_type.java.classname) %>.<%= uppercase_constantize(attribute.java.field_name) %>_ATTR_ID & attributesMask) )
      {
        try
        {
<% if is_primitive && attr_type == :integer %>          output.writeInt( bean.get<%= name %>() );
<% elsif attr_type == :integer %>          output.writeInt( (bean.get<%= name %>() == null) ? 0 : bean.get<%= name %>() );
<% elsif attr_type == :i_enum %>          output.writeByte( (bean.get<%= name %>() == null) ? (byte)0 : (byte)bean.get<%= name %>().getValue() );
<% elsif is_primitive && attr_type == :boolean %>          output.writeBoolean( bean.get<%= name %>() );
<% elsif attr_type == :boolean %>          output.writeBoolean( (bean.get<%= name %>() == null) ? false : bean.get<%= name %>() );
<% elsif attr_type == :string || attr_type == :s_enum %>          output.writeUTF( (bean.get<%= name %>() == null) ? "\0" : bean.get<%= name %>() );
<% elsif attr_type == :datetime %>          output.writeLong( (bean.get<%= name %>() == null) ? Long.MAX_VALUE : bean.get<%= name %>().getTime() );
<% else %>          throw new IllegalStateException( "Unknown attribute type transmitted <%= attr_type %>" );<% end %>
        }
        catch ( final RuntimeException e )
        {
           bean.printWarning("Failed to write attribute <%= name %> of type <%= attr_type %> with value '" + bean.get<%= name %>() + "'" );
           throw e;
        }
      }
<% end %>
      output.flush();
   }
<% end %>
}