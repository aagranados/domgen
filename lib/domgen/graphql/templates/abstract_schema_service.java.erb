/* DO NOT EDIT: File is auto-generated */
package <%= to_package(repository.graphql.qualified_abstract_schema_service_name) %>;

/*

Define a subclass that looks like:

@ApplicationScoped
@Transactional( Transactional.TxType.REQUIRED )
@Typed( GraphQLSchemaProvider.class )
public class <%= repository.graphql.schema_service_name %>
  extends <%= repository.graphql.qualified_abstract_schema_service_name %>
{
  ...

  @Override
  protected void wireSchema( @Nonnull final RuntimeWiring.Builder builder )
  {
    super.wireSchema( builder );
    ...
  }
}

 */
@javax.annotation.Generated( "Domgen" )
@java.lang.SuppressWarnings( { "UnusedDeclaration", "JavaDoc", "PMD.UnusedPrivateField", "PMD.UnnecessaryLocalBeforeReturn" } )
@edu.umd.cs.findbugs.annotations.SuppressFBWarnings( { "ACEM_ABSTRACT_CLASS_EMPTY_METHODS", "UI_INHERITANCE_UNSAFE_GETRESOURCE", "EXS_EXCEPTION_SOFTENING_NO_CONSTRAINTS" } )
public abstract class <%= repository.graphql.abstract_schema_service_name %>
  implements graphql.servlet.config.GraphQLSchemaProvider
{
  @javax.annotation.Resource( lookup = "java:appserver/TransactionManager" )
  private javax.transaction.TransactionManager _transactionManager;
  @javax.annotation.Resource( lookup = "<%= repository.graphql.context_service_jndi_name %>" )
  private javax.enterprise.concurrent.ContextService _contextService;
  private graphql.schema.GraphQLSchema _schema;
  private graphql.schema.GraphQLSchema _readOnlySchema;
<% repository.data_modules.select(&:graphql?).each do |data_module| -%>
<% data_module.services.select{|service| service.graphql? && service.methods.any?{|method| method.graphql?}}.each do |service| -%>
  @javax.inject.Inject
  private <%= service.ejb.qualified_service_name %> _<%= Reality::Naming.camelize(service.name) %>;
<% end -%>
<% end -%>
<% if repository.imit? -%>
  @javax.inject.Inject
  private org.realityforge.replicant.server.EntityMessageEndpoint _endpoint;
  @javax.persistence.PersistenceContext( unitName = <%= repository.jpa.qualified_unit_descriptor_name %>.NAME )
  private javax.persistence.EntityManager _entityManager;
  @javax.annotation.Resource
  private javax.transaction.TransactionSynchronizationRegistry _registry;
  @javax.inject.Inject
  private org.realityforge.replicant.server.transport.ReplicantSessionManager _sessionManager;

  @javax.annotation.Nonnull
  protected <T> graphql.schema.DataFetcher<T> wrapInTransaction( @javax.annotation.Nonnull final String key, @javax.annotation.Nonnull final graphql.schema.DataFetcher<T> fetcher )
  {
    return new <%= repository.graphql.qualified_transactional_data_fetcher_name %><>( _transactionManager, new org.realityforge.replicant.server.graphql.ReplicantEnabledDataFetcher<>( _sessionManager, _endpoint, _entityManager, _registry, key, fetcher ) );
  }
<% end -%>

  @javax.annotation.PostConstruct
  protected void postConstruct()
  {
    _schema = buildGraphQLSchema();
    _readOnlySchema = graphql.servlet.config.GraphQLSchemaProvider.copyReadOnly( _schema );
  }

  @SuppressWarnings( "unchecked" )
  @javax.annotation.Nonnull
  protected <T> graphql.schema.DataFetcher<T> topLevelDataFetcher( @javax.annotation.Nonnull final String key,
                                                                   final boolean wrapInTransaction,
                                                                   @javax.annotation.Nonnull final graphql.schema.DataFetcher<T> fetcher )
  {
    final graphql.schema.DataFetcher<T> dataFetcher = wrapInTransaction ? wrapInTransaction( key, fetcher ) : fetcher;
    return (graphql.schema.DataFetcher<T>) _contextService.createContextualProxy( dataFetcher, graphql.schema.DataFetcher.class );
  }

<% unless repository.imit? -%>
  @javax.annotation.Nonnull
  protected <T> graphql.schema.DataFetcher<T> wrapInTransaction( @javax.annotation.Nonnull final String key, @javax.annotation.Nonnull final graphql.schema.DataFetcher<T> fetcher )
  {
    return new <%= repository.graphql.qualified_transactional_data_fetcher_name %><>( _transactionManager, fetcher );
  }

<% end -%>
  @javax.annotation.Nonnull
  protected java.util.List<java.lang.String> getSchemaResources()
  {
    return java.util.Collections.singletonList( "/<%= repository.graphql.qualified_schema_name.gsub(".","/") %>.graphqls" );
  }

  protected void wireSchema( @javax.annotation.Nonnull final graphql.schema.idl.RuntimeWiring.Builder builder )
  {
<% repository.graphql.non_standard_scalars.select{|scalar| %w(LocalDate LocalDateTime).include?(scalar)}.each do |scalar| -%>
    builder.scalar( org.realityforge.graphql.scalars.Scalars.<%= Reality::Naming.uppercase_constantize(scalar) %> );
<% end -%>
    final graphql.schema.GraphQLCodeRegistry.Builder registry = graphql.schema.GraphQLCodeRegistry.newCodeRegistry();
    wireMutations( registry );
    wireCodeRegistry( registry );
    builder.codeRegistry( registry.build() );
  }

  protected void wireMutations( @javax.annotation.Nonnull final graphql.schema.GraphQLCodeRegistry.Builder registry )
  {
<% repository.data_modules.select(&:graphql?).each do |data_module| -%>
<% data_module.services.select(&:graphql?).each do |service| -%>
<% service.methods.select{|method| method.graphql? && method.graphql.mutation?}.each do |method| -%>
  registry.dataFetcher( graphql.schema.FieldCoordinates.coordinates( "Mutation", "<%= method.graphql.name %>" ), wrapInTransaction( "graphql.mutation.<%= method.graphql.name %>", this::<%= method.graphql.name %> ) );
<% end -%>
<% end -%>
<% end -%>
  }

  protected abstract void wireCodeRegistry( @javax.annotation.Nonnull graphql.schema.GraphQLCodeRegistry.Builder registry );

  @javax.annotation.Nonnull
  private graphql.schema.GraphQLSchema buildGraphQLSchema()
  {
    final graphql.schema.idl.SchemaParser schemaParser = new graphql.schema.idl.SchemaParser();
    final graphql.schema.idl.SchemaGenerator schemaGenerator = new graphql.schema.idl.SchemaGenerator();

    final graphql.schema.idl.TypeDefinitionRegistry typeRegistry = new graphql.schema.idl.TypeDefinitionRegistry();

    // each schema is merged into a single type registry
    for ( final String resourceName : getSchemaResources() )
    {
      try ( java.io.InputStream inputStream = getClass().getResourceAsStream( resourceName ) )
      {
        if ( null == inputStream )
        {
          throw new IllegalStateException( "Attempting to load resource named '" + resourceName +
                                           "' to populate the GraphQL type definition registry but " +
                                           "the resource does not exist on the classpath." );
        }
        typeRegistry.merge( schemaParser.parse( new java.io.InputStreamReader( inputStream, java.nio.charset.StandardCharsets.UTF_8 ) ) );
      }
      catch ( final java.io.IOException ioe )
      {
        throw new IllegalStateException( "Attempting to load resource named '" + resourceName +
                                         "' to populate the GraphQL type definition registry but " +
                                         "there was an error loading the resource from the classpath: " + ioe,
                                         ioe );
      }
    }

    final graphql.schema.idl.RuntimeWiring.Builder builder = graphql.schema.idl.RuntimeWiring.newRuntimeWiring();
    wireSchema( builder );
    final graphql.schema.GraphQLSchema schema = schemaGenerator.makeExecutableSchema( typeRegistry, builder.build() );
    new graphql.schema.validation.SchemaValidator().validateSchema( schema );
    return schema;
  }

  @java.lang.Override
  public graphql.schema.GraphQLSchema getSchema( final javax.servlet.http.HttpServletRequest request )
  {
    return getSchema();
  }

  @java.lang.Override
  public graphql.schema.GraphQLSchema getSchema( final javax.websocket.server.HandshakeRequest request )
  {
    return getSchema();
  }

  @java.lang.Override
  public graphql.schema.GraphQLSchema getSchema()
  {
    return _schema;
  }

  @java.lang.Override
  public graphql.schema.GraphQLSchema getReadOnlySchema( final javax.servlet.http.HttpServletRequest request )
  {
    return _readOnlySchema;
  }

  @javax.annotation.Nonnull
  protected javax.persistence.EntityManager em()
  {
    return _entityManager;
  }
<% repository.data_modules.select(&:graphql?).each do |data_module| -%>
<% data_module.services.select(&:graphql?).each do |service| -%>
<% service.methods.select{|method| method.graphql? && method.graphql.mutation?}.each do |method| -%>

  @javax.annotation.Nonnull
  protected java.util.Map<String, Object> <%= method.graphql.name %>( @javax.annotation.Nonnull final graphql.schema.DataFetchingEnvironment e )
  {
    final iris.rose.server.graphql.<%= Reality::Naming.pascal_case(method.graphql.name) %>Args args = iris.rose.server.graphql.<%= Reality::Naming.pascal_case(method.graphql.name) %>Args.from( e );
<% method.parameters.select{|parameter|parameter.graphql? && parameter.graphql.output? && (parameter.reference? || parameter.struct?)}.each do |parameter| -%>
    final <%= parameter.ejb.java_type %> <%= Reality::Naming.camelize(parameter.name) %> = <%= graphql_resolve_parameter(parameter) %>;
<% end -%>
    <% if method.return_value.graphql? -%>final <%= method.return_value.ejb.java_type %> <%= method.return_value.graphql.name %> = <% end %>_<%= Reality::Naming.camelize(service.name) %>.<%= Reality::Naming.camelize(method.name) %>( <%= method.parameters.collect{|parameter| (parameter.reference? || parameter.struct?) && parameter.graphql.output? ? Reality::Naming.camelize(parameter.name) : graphql_resolve_parameter(parameter) }.join(', ') -%> );
    final java.util.Map<String, Object> $result = new java.util.HashMap<>();
<% if method.return_value.graphql? -%>
    $result.put( "<%= method.return_value.graphql.name %>", <%= method.return_value.graphql.name %> );
<% end -%>
<% method.parameters.select{|parameter|parameter.graphql? && parameter.graphql.output?}.each do |parameter| -%>
    $result.put( "<%= parameter.graphql.name %>", <%= parameter.reference? || parameter.struct? ? Reality::Naming.camelize(parameter.name) : "args.get#{parameter.name}()" %> );
<% end -%>
    return successResponse( args.getClientMutationId(), $result );
  }
<% end -%>
<% end -%>
<% end -%>
<% repository.data_modules.select(&:graphql?).each do |data_module| -%>
<% data_module.structs.select{|struct| struct.graphql? && struct.graphql.input?}.each do |struct| -%>

  @javax.annotation.Nonnull
  protected <%= struct.ee.qualified_name %> asStruct( @javax.annotation.Nonnull final iris.rose.server.graphql.<%= struct.graphql.input_name %> input )
  {
    return new <%= struct.ee.qualified_name %>(<%= struct.fields.collect{|field|
  input_value = "input.get#{field.name}()"
  value = input_value
  value = field.collection? ? "#{value}.stream().map( this::asStruct ).collect( java.util.stream.Collectors.toList() )" : value
  value = field.collection? && field.nullable? ? "null == #{input_value} ? null : #{value}" : value
  value
  }.join(", ") %>);
  }
<% end -%>
<% end -%>

  @javax.annotation.Nonnull
  protected java.util.Map<String, Object> successResponse( @javax.annotation.Nullable final String clientMutationId, @javax.annotation.Nonnull final java.util.Map<String, Object> result )
  {
    final java.util.Map<String, Object> data = new java.util.HashMap<>();
    data.put( "clientMutationId", clientMutationId );
    data.put( "result", result );
    return data;
  }

  @SuppressWarnings( "checkstyle:MethodTypeParameterName" )
  @javax.annotation.Nonnull
  protected <EntityType, IdType> java.util.List<EntityType> asEntityList( @javax.annotation.Nonnull final graphql.schema.DataFetchingEnvironment e, @javax.annotation.Nonnull final Class<EntityType> clazz, @javax.annotation.Nonnull final String argName, @javax.annotation.Nonnull final String typeName, @javax.annotation.Nonnull final java.util.Collection<IdType> values )
  {
    return values.stream()
      .map( id -> asEntity( e, clazz, argName, typeName, id ) )
      .collect( java.util.stream.Collectors.toList() );
  }

  @SuppressWarnings( "checkstyle:MethodTypeParameterName" )
  @javax.annotation.Nonnull
  protected <EntityType> EntityType asEntity( @javax.annotation.Nonnull final graphql.schema.DataFetchingEnvironment e, @javax.annotation.Nonnull final Class<EntityType> clazz, @javax.annotation.Nonnull final String argName, @javax.annotation.Nonnull final String typeName, @javax.annotation.Nonnull final Object id )
  {
    final EntityType entity = _entityManager.find( clazz, id );
    if ( null == entity )
    {
      throw new graphql.schema.CoercingParseValueException( "Argument '" + argName + "' contains an id with no " + typeName + " entity associated with the id. The entity may have been deleted.",
                                                            null,
                                                            e.getMergedField().getArguments().stream().filter( a -> a.getName().equals( argName ) ).map( graphql.language.Argument::getSourceLocation ).findAny().orElse( null ) );
    }
    return entity;
  }
}
