/* DO NOT EDIT: File is auto-generated */
package <%= to_package(repository.graphql.qualified_abstract_schema_service_name) %>;

/*

Define a subclass that looks like:

@ApplicationScoped
@Transactional( Transactional.TxType.REQUIRED )
@Typed( GraphQLSchemaService.class )
public class <%= repository.graphql.schema_service_name %>
  extends <%= repository.graphql.qualified_abstract_schema_service_name %>
{
  ...

  @Override
  protected void wireSchema( @Nonnull final RuntimeWiring.Builder builder )
  {
    super.wireSchema( builder );
    ...
  }
}

 */
@javax.annotation.Generated( "Domgen" )
@java.lang.SuppressWarnings( { "UnusedDeclaration", "JavaDoc", "PMD.UnusedPrivateField", "PMD.UnnecessaryLocalBeforeReturn" } )
@edu.umd.cs.findbugs.annotations.SuppressFBWarnings( { "ACEM_ABSTRACT_CLASS_EMPTY_METHODS" } )
public abstract class <%= repository.graphql.abstract_schema_service_name %>
  implements org.realityforge.graphql.domgen.GraphQLSchemaService
{
  @javax.annotation.Resource( lookup = "java:appserver/TransactionManager" )
  private javax.transaction.TransactionManager _transactionManager;
  @javax.annotation.Resource( lookup = "<%= repository.graphql.context_service_jndi_name %>" )
  private javax.enterprise.concurrent.ContextService _contextService;
  @javax.annotation.Nullable
  private graphql.servlet.config.GraphQLSchemaProvider _schemaProvider;
<% if repository.imit? -%>
  @javax.inject.Inject
  private org.realityforge.replicant.server.EntityMessageEndpoint _endpoint;
  @javax.persistence.PersistenceContext( unitName = <%= repository.jpa.qualified_unit_descriptor_name %>.NAME )
  private javax.persistence.EntityManager _entityManager;
  @javax.annotation.Resource
  private javax.transaction.TransactionSynchronizationRegistry _registry;
  @javax.inject.Inject
  private org.realityforge.replicant.server.transport.ReplicantSessionManager _sessionManager;

  @javax.annotation.Nonnull
  protected <T> graphql.schema.DataFetcher<T> wrapInTransaction( @javax.annotation.Nonnull final String key, @javax.annotation.Nonnull final graphql.schema.DataFetcher<T> fetcher )
  {
  return super.wrapInTransaction( key, new org.realityforge.replicant.server.graphql.ReplicantEnabledDataFetcher<>( _sessionManager, _endpoint, _entityManager, _registry, key, fetcher ) );
  }
<% end -%>

  @javax.annotation.PostConstruct
  protected void postConstruct()
  {
    _schemaProvider = new graphql.servlet.config.DefaultGraphQLSchemaProvider( buildGraphQLSchema() );
  }

  @javax.annotation.Nonnull
  @java.lang.Override
  public graphql.servlet.config.GraphQLSchemaProvider getProvider()
  {
    assert null != _schemaProvider;
    return _schemaProvider;
  }

  @SuppressWarnings( "unchecked" )
  @javax.annotation.Nonnull
  protected <T> graphql.schema.DataFetcher<T> topLevelDataFetcher( @javax.annotation.Nonnull final String key,
                                                                   final boolean wrapInTransaction,
                                                                   @javax.annotation.Nonnull final graphql.schema.DataFetcher<T> fetcher )
  {
    final graphql.schema.DataFetcher dataFetcher = wrapInTransaction ? wrapInTransaction( key, fetcher ) : fetcher;
    return (graphql.schema.DataFetcher<T>) _contextService.createContextualProxy( dataFetcher, graphql.schema.DataFetcher.class );
  }

  @javax.annotation.Nonnull
  protected <T> graphql.schema.DataFetcher<T> wrapInTransaction( @javax.annotation.Nonnull final String key, @javax.annotation.Nonnull final graphql.schema.DataFetcher<T> fetcher )
  {
    return new org.realityforge.graphql.domgen.TransactionEnabledDataFetcher<>( _transactionManager, fetcher );
  }

  @javax.annotation.Nonnull
  protected java.util.List<java.lang.String> getSchemaResources()
  {
    return java.util.Collections.singletonList( "/<%= repository.graphql.qualified_schema_name.gsub(".","/") %>.graphqls" );
  }

  protected void wireSchema( @javax.annotation.Nonnull final graphql.schema.idl.RuntimeWiring.Builder builder )
  {
<% repository.graphql.non_standard_scalars.select{|scalar| %w(LocalDate LocalDateTime).include?(scalar)}.each do |scalar| -%>
    builder.scalar( org.realityforge.graphql.domgen.Scalars.<%= Reality::Naming.uppercase_constantize(scalar) %> );
<% end -%>
    final graphql.schema.GraphQLCodeRegistry.Builder registry = graphql.schema.GraphQLCodeRegistry.newCodeRegistry();
    wireCodeRegistry( registry );
    builder.codeRegistry( registry.build() );
  }

  protected void wireCodeRegistry( @javax.annotation.Nonnull final graphql.schema.GraphQLCodeRegistry.Builder registry )
  {
  }

  @javax.annotation.Nonnull
  private graphql.schema.GraphQLSchema buildGraphQLSchema()
  {
    final graphql.schema.idl.SchemaParser schemaParser = new graphql.schema.idl.SchemaParser();
    final graphql.schema.idl.SchemaGenerator schemaGenerator = new graphql.schema.idl.SchemaGenerator();

    final graphql.schema.idl.TypeDefinitionRegistry typeRegistry = new graphql.schema.idl.TypeDefinitionRegistry();

    // each schema is merged into a single type registry
    for ( final String resourceName : getSchemaResources() )
    {
      try ( final java.io.InputStream inputStream = getClass().getResourceAsStream( resourceName ) )
      {
        if ( null == inputStream )
        {
          throw new IllegalStateException( "Attempting to load resource named '" + resourceName +
                                           "' to populate the GraphQL type definition registry but " +
                                           "the resource does not exist on the classpath." );
        }
        typeRegistry.merge( schemaParser.parse( new java.io.InputStreamReader( inputStream ) ) );
      }
      catch ( final java.io.IOException ioe )
      {
        throw new IllegalStateException( "Attempting to load resource named '" + resourceName +
                                         "' to populate the GraphQL type definition registry but " +
                                         "there was an error loading the resource from the classpath: " + ioe,
                                         ioe );
      }
    }

    final graphql.schema.idl.RuntimeWiring.Builder builder = graphql.schema.idl.RuntimeWiring.newRuntimeWiring();
    wireSchema( builder );
    final graphql.schema.GraphQLSchema schema = schemaGenerator.makeExecutableSchema( typeRegistry, builder.build() );
    new graphql.schema.validation.SchemaValidator().validateSchema( schema );
    return schema;
  }
}
