/* DO NOT EDIT: File is auto-generated */
package <%= to_package(repository.graphql.qualified_abstract_schema_service_name) %>;

/*

Define a subclass that looks like:

@ApplicationScoped
@Transactional( Transactional.TxType.REQUIRED )
@Typed( GraphQLSchemaService.class )
public class <%= repository.graphql.schema_service_name %>
  extends <%= repository.graphql.qualified_abstract_schema_service_name %>
{
  ...

  @Override
  protected void wireSchema( @Nonnull final RuntimeWiring.Builder builder )
  {
    super.wireSchema( builder );
    ...
  }
}

 */
@javax.annotation.Generated( "Domgen" )
@java.lang.SuppressWarnings( { "UnusedDeclaration", "JavaDoc", "PMD.UnusedPrivateField", "PMD.UnnecessaryLocalBeforeReturn" } )
@edu.umd.cs.findbugs.annotations.SuppressFBWarnings( { "ACEM_ABSTRACT_CLASS_EMPTY_METHODS" } )
public abstract class <%= repository.graphql.abstract_schema_service_name %>
  extends org.realityforge.graphql.domgen.Abstract<%= repository.imit? ? 'Replicant' : '' %>GraphQLSchemaService
{
  @javax.annotation.Resource( lookup = "java:appserver/TransactionManager" )
  private javax.transaction.TransactionManager _transactionManager;
  @javax.annotation.Resource( lookup = "<%= repository.graphql.context_service_jndi_name %>" )
  private javax.enterprise.concurrent.ContextService _contextService;
<% if repository.imit? -%>
  @javax.inject.Inject
  private org.realityforge.replicant.server.EntityMessageEndpoint _endpoint;
  @javax.persistence.PersistenceContext( unitName = <%= repository.jpa.qualified_unit_descriptor_name %>.NAME )
  private javax.persistence.EntityManager _entityManager;
  @javax.annotation.Resource
  private javax.transaction.TransactionSynchronizationRegistry _registry;
  @javax.inject.Inject
  private org.realityforge.replicant.server.transport.ReplicantSessionManager _sessionManager;

  @javax.annotation.PostConstruct
  protected void postConstruct()
  {
    super.initSchemaProvider();
  }

  @javax.annotation.Nonnull
  @java.lang.Override
  protected org.realityforge.replicant.server.transport.ReplicantSessionManager getReplicantSessionManager()
  {
    return _sessionManager;
  }

  @javax.annotation.Nonnull
  @java.lang.Override
  protected javax.transaction.TransactionSynchronizationRegistry getRegistry()
  {
    return _registry;
  }

  @javax.annotation.Nonnull
  @java.lang.Override
  protected org.realityforge.replicant.server.EntityMessageEndpoint getEndpoint()
  {
    return _endpoint;
  }

  @javax.annotation.Nonnull
  @java.lang.Override
  protected javax.persistence.EntityManager getEntityManager()
  {
    return _entityManager;
  }
<% end -%>
  @javax.annotation.Nonnull
  @java.lang.Override
  protected javax.enterprise.concurrent.ContextService getContextService()
  {
    return _contextService;
  }

  @javax.annotation.Nonnull
  @java.lang.Override
  protected javax.transaction.TransactionManager getTransactionManager()
  {
    return _transactionManager;
  }

  @javax.annotation.Nonnull
  @java.lang.Override
  protected java.util.List<java.lang.String> getSchemaResources()
  {
    return java.util.Collections.singletonList( "/<%= repository.graphql.qualified_schema_name.gsub(".","/") %>.graphqls" );
  }

  @java.lang.Override
  protected void wireSchema( @javax.annotation.Nonnull final graphql.schema.idl.RuntimeWiring.Builder builder )
  {
<% repository.graphql.non_standard_scalars.select{|scalar| %w(Date DateTime).include?(scalar)}.each do |scalar| -%>
    builder.scalar( org.realityforge.graphql.domgen.Scalars.<%= Reality::Naming.uppercase_constantize(scalar) %> );
<% end -%>
    final graphql.schema.GraphQLCodeRegistry.Builder registry = graphql.schema.GraphQLCodeRegistry.newCodeRegistry();
    wireCodeRegistry( registry );
    builder.codeRegistry( registry.build() );
  }

  protected void wireCodeRegistry( @javax.annotation.Nonnull final graphql.schema.GraphQLCodeRegistry.Builder registry )
  {
  }
}
