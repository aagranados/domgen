/* DO NOT EDIT: File is auto-generated */
package <%= repository.imit.encoder_package %>;

import org.realityforge.imit.server.EntityMessage;

/**
 * * Utility class that encodes RPC payloads from JPA entities for the repository "<%= repository.name %>".
 */
@javax.annotation.Generated( "Domgen" )
@SuppressWarnings( { "UnusedDeclaration", "JavaDoc" } )
public class <%= repository.imit.jpa_change_recorder_name %>
{
  @javax.annotation.Resource
  private javax.transaction.TransactionSynchronizationRegistry _registry;
<% repository.imit.client_side_data_modules.each do |data_module| %>
  private final <%= data_module.imit.qualified_router_interface_name %> _<%= data_module.name %>Router = new <%= data_module.imit.qualified_router_interface_name %>Impl();
<% end %>


  @javax.persistence.PostUpdate
  @javax.persistence.PostPersist
  public void postUpdate( final Object object )
  {
    <% repository.imit.concrete_client_side_entities.each do |entity|
%>if( <%= entity.jpa.qualified_entity_name %>.class.isInstance( object ) )
    {
      final <%= entity.jpa.qualified_entity_name %> entity = <%= entity.jpa.qualified_entity_name %>.class.cast( object );
      final @javax.annotation.Nonnull java.io.Serializable id = entity.<%= getter_for(entity.primary_key) %>;
      final @javax.annotation.Nonnull java.util.Map<String, java.io.Serializable> attributes = <%= entity.data_module.imit.qualified_jpa_encoder_name %>.encode<%= entity.name %>( entity );
      final int transportID = <%= entity.imit.transport_id %>;
      final @javax.annotation.Nonnull java.util.Map<String, java.io.Serializable> routingKeys = _<%= entity.data_module.name %>Router.route<%= entity.name %>( entity );
      final EntityMessage change = new EntityMessage( id, transportID, routingKeys, attributes );
      addChange( change );
    }
    else <%
   end
%>
    {
      //Ignore
    }
  }

  @javax.persistence.PostRemove
  public void postRemove( final Object object )
  {
<% repository.imit.concrete_client_side_entities.each do |entity|
%>if( <%= entity.jpa.qualified_entity_name %>.class.isInstance( object ) )
    {
      final <%= entity.jpa.qualified_entity_name %> entity = <%= entity.jpa.qualified_entity_name %>.class.cast( object );
      final @javax.annotation.Nonnull java.io.Serializable id = entity.<%= getter_for(entity.primary_key) %>;
      final int transportID = <%= entity.imit.transport_id %>;
      final @javax.annotation.Nonnull java.util.Map<String, java.io.Serializable> routingKeys = _<%= entity.data_module.name %>Router.route<%= entity.name %>( entity );
      final EntityMessage change = new EntityMessage( id, transportID, routingKeys, null );
      addChange( change );
    }
    else <%
 end
%>
    {
      //Ignore
    }
  }

  @SuppressWarnings( { "unchecked" } )
  private void addChange( final EntityMessage change )
  {
    final javax.transaction.TransactionSynchronizationRegistry registry = getRegistry();
    java.util.LinkedList<EntityMessage> changes = (java.util.LinkedList<EntityMessage>) registry.getResource( EntityMessage.KEY );
    if ( null == changes )
    {
      changes = new java.util.LinkedList<EntityMessage>();
      registry.putResource( EntityMessage.KEY, changes );
    }
    changes.add( change );
  }

  /**
   * Access registry via JNDI. Can not use @javax.annotation.Resource as JPA 2.0 does not
   * support it. However our Guice based test infrastructure uses it.
   */
  private javax.transaction.TransactionSynchronizationRegistry getRegistry()
  {
    if ( null == _registry )
    {
      try
      {
        _registry = (javax.transaction.TransactionSynchronizationRegistry)
          new javax.naming.InitialContext().lookup( "java:comp/TransactionSynchronizationRegistry" );
      }
      catch ( final javax.naming.NamingException ne )
      {
        throw new IllegalStateException( "Unable to locate TransactionSynchronizationRegistry due to " + ne, ne );
      }
    }
    return _registry;
  }
}
