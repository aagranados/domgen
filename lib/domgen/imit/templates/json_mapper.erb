/* DO NOT EDIT: File is auto-generated */
package <%= data_module.imit.imitation_package %>;

import footprints.javancss.imit.EntityChangeBroker;

/**
 * Utility class that decodes JSON payloads and applies the changes to the entities
 * in the associated entity repository for the data module "<%= data_module.name %>".
 */
@javax.annotation.Generated( "Domgen" )
@SuppressWarnings( { "UnusedDeclaration", "JavaDoc" } )
public class <%= data_module.imit.json_mapper_name %>
{
  private final @javax.annotation.Nonnull <%= data_module.imit.updater_name %> _<%= data_module.name %>Updater;

  public <%= data_module.imit.json_mapper_name %>( final @javax.annotation.Nonnull EntityChangeBroker broker )
  {
    _<%= data_module.name %>Updater = new <%= data_module.imit.updater_name %>( broker );
  }

<% data_module.entities.each do |entity| %>
  void update<%= entity.name %>( final <%= entity.name %> entity, final org.json.JSONObject object, final boolean fullUpdate )
      throws org.json.JSONException
  {
<% entity.declared_attributes.select{|attribute| !attribute.primary_key? && attribute.imit.client_side? }.each do |attribute|
    attribute_name = attribute.imit.field_name
    attribute_type = attribute.attribute_type

    if attribute.attribute_type == :reference
      attribute_name = attribute.referencing_link_name
      attribute_type = attribute.referenced_entity.primary_key.attribute_type
    end
    value_converter =
        if attribute_type == :datetime
          "new java.sql.Timestamp( object.getLong( #{entity.name}.#{uppercase_constantize(attribute.name)} ) )"
        elsif attribute_type == :integer
          "object.getInt( #{entity.name}.#{uppercase_constantize(attribute.name)} )"
        elsif attribute_type == :real
          "object.getDouble( #{entity.name}.#{uppercase_constantize(attribute.name)} )"
        elsif attribute_type == :boolean
          "object.getBoolean( #{entity.name}.#{uppercase_constantize(attribute.name)} )"
        elsif attribute_type == :string || attribute.attribute_type == :text
          "object.getString( #{entity.name}.#{uppercase_constantize(attribute.name)} )"
        elsif attribute_type == :enumeration && attribute.enumeration.textual_values?
          "#{attribute.enumeration.imit.qualified_enumeration_name}.valueOf( object.getString( #{entity.name}.#{uppercase_constantize(attribute.name)} ) )"
        elsif attribute_type == :enumeration && attribute.enumeration.numeric_values?
          "#{attribute.enumeration.imit.qualified_enumeration_name}.values()[ object.getInt( #{entity.name}.#{uppercase_constantize(attribute.name)} ) ]"
        else
          raise "Unable to convert data type #{attribute_type} on #{attribute.qualified_name}"
        end
%>    if( fullUpdate || object.has( <%= entity.name %>.<%= uppercase_constantize( attribute.name ) %> ) )
    {
      _<%= data_module.name %>Updater.set<%= attribute_name %>_On_<%= entity.name %>( entity, <%= value_converter %> );
    }
<% end %>
  }
<% end %>
}
