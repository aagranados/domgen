/* DO NOT EDIT: File is auto-generated */
package <%= data_module.imit.imitation_package %>;

import org.realityforge.imit.EntityChangeBroker;
import org.realityforge.imit.EntityRepository;

/**
 * Utility class that decodes JSON payloads and applies the changes to the entities
 * in the associated entity repository for the data module "<%= data_module.name %>".
 */
@javax.annotation.Generated( "Domgen" )
@SuppressWarnings( { "UnusedDeclaration", "JavaDoc" } )
public class <%= data_module.imit.json_mapper_name %>
{
  public static final String TYPE_PREFIX = "<%= data_module.name %>";

  private final EntityRepository _repository;
  private final EntityChangeBroker _broker;
  private final <%= data_module.imit.updater_name %> _<%= data_module.name %>Updater;

  public <%= data_module.imit.json_mapper_name %>( final @javax.annotation.Nonnull EntityRepository repository, final @javax.annotation.Nonnull EntityChangeBroker broker )
  {
    _repository = repository;
    _broker = broker;
    _<%= data_module.name %>Updater = new <%= data_module.imit.updater_name %>( broker );
  }

  public void create( final Object id, final String typeName, final org.json.JSONObject object )
      throws org.json.JSONException
  {
    <% data_module.entities.select{|entity| !entity.abstract?}.each do |entity|
%>if( <%= entity.imit.imitation_name %>.TYPE_KEY.equals( typeName ) )
    {
      create<%= entity.name %>( id, object );
    }
    else <%
end %>
    {
      throw new IllegalStateException("Unknown type specified " + typeName );
    }
  }

  public void update( final Object id, final String typeName, final org.json.JSONObject object )
      throws org.json.JSONException
  {
    <% data_module.entities.select{|entity| !entity.abstract?}.each do |entity|
%>if( <%= entity.imit.imitation_name %>.TYPE_KEY.equals( typeName ) )
    {
      final <%= entity.imit.imitation_name %> entity = _repository.getByID( <%= entity.imit.imitation_name %>.class, id );
      update<%= entity.name %>( entity, object, false );
    }
    else <%
end %>
    {
      throw new IllegalStateException("Unknown type specified " + typeName );
    }
  }

  public void delete( final Object id, final String typeName )
  {
    <% data_module.entities.select{|entity| !entity.abstract?}.each do |entity|
%>if( <%= entity.imit.imitation_name %>.TYPE_KEY.equals( typeName ) )
    {
      delete<%= entity.name %>( id );
    }
    else <%
end %>
    {
      throw new IllegalStateException("Unknown type specified " + typeName );
    }
  }

<% data_module.entities.each do |entity| %>
<% if !entity.abstract? %>
  void create<%= entity.name %>( final Object id, final org.json.JSONObject object )
      throws org.json.JSONException
  {
    final <%= entity.imit.imitation_name %> entity = new <%= entity.imit.imitation_name %>( _repository );
    _broker.deactivate();
    try
    {
      _repository.registerEntity( <%= entity.imit.imitation_name %>.class, id, entity );
      update<%= entity.name %>( entity, object, true );
    }
    finally
    {
      _broker.activate();
    }
  }

  void delete<%= entity.name %>( final Object id )
  {
    final <%= entity.imit.imitation_name %> entity =
      _repository.deregisterEntity( <%= entity.imit.imitation_name %>.class, id );
    entity.invalidate();
  }
<% end %>
  void update<%= entity.name %>( final <%= entity.imit.imitation_name %> entity, final org.json.JSONObject object, final boolean fullUpdate )
      throws org.json.JSONException
  {
<% if entity.extends
   other = entity.data_module.entity_by_name(entity.extends)
%>    update<%= other.name %>( entity, object, fullUpdate );
<% end %>
<% entity.declared_attributes.select{|attribute| attribute.imit.client_side? }.each do |attribute|
    value_converter =
        if attribute.imit.transport_attribute_type == :datetime
          "new java.sql.Timestamp( object.getLong( #{entity.name}.#{uppercase_constantize(attribute.name)} ) )"
        elsif attribute.imit.transport_attribute_type == :integer
          "object.getInt( #{entity.name}.#{uppercase_constantize(attribute.name)} )"
        elsif attribute.imit.transport_attribute_type == :real
          "object.getDouble( #{entity.name}.#{uppercase_constantize(attribute.name)} )"
        elsif attribute.imit.transport_attribute_type == :boolean
          "object.getBoolean( #{entity.name}.#{uppercase_constantize(attribute.name)} )"
        elsif attribute.imit.transport_attribute_type == :string || attribute.imit.transport_attribute_type == :text
          "object.getString( #{entity.name}.#{uppercase_constantize(attribute.name)} )"
        elsif attribute.imit.transport_attribute_type == :enumeration && attribute.enumeration.textual_values?
          "#{attribute.enumeration.imit.qualified_enumeration_name}.valueOf( object.getString( #{entity.name}.#{uppercase_constantize(attribute.name)} ) )"
        elsif attribute.imit.transport_attribute_type == :enumeration && attribute.enumeration.numeric_values?
          "#{attribute.enumeration.imit.qualified_enumeration_name}.values()[ object.getInt( #{entity.name}.#{uppercase_constantize(attribute.name)} ) ]"
        else
          raise "Unable to convert data type #{attribute.imit.transport_attribute_type} on #{attribute.qualified_name}"
        end
%>    if( fullUpdate <% if !attribute.primary_key? %>|| object.has( <%= entity.name %>.<%= uppercase_constantize( attribute.name ) %> )<% end %> )
    {
      _<%= data_module.name %>Updater.set<%= attribute.imit.transport_name %>_On_<%= entity.name %>( entity, <%= value_converter %> );
    }
<% end %>
  }
<% end %>
}
