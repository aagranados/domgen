/* DO NOT EDIT: File is auto-generated */
package <%= entity.data_module.imit.imitation_package %>;

import org.realityforge.imit.EntityRepository;

<%= description_javadoc_for(entity, "") %>@javax.annotation.Generated( "Domgen" )
@SuppressWarnings( { "UnusedDeclaration", "JavaDoc" } )
public <%= entity.abstract? ? "abstract " : "" %>class <%= entity.imit.imitation_name %>
<%= entity.extends ?
  "    extends #{entity.data_module.entity_by_name(entity.extends).imit.qualified_imitation_name}\n" :
  "" %>
{
  public static final String TYPE_KEY = "<%= entity.qualified_name %>";
<% if !entity.abstract? %>
  public static final int TRANSPORT_ID = <%= entity.imit.transport_id %>;
<% end %>
<% entity.declared_attributes.select{ |attribute| attribute.imit.client_side? }.each do |attribute|
%>  public static final String <%= uppercase_constantize( attribute.name ) %> = "<%= attribute.name %>";
<% end %>
<%= entity.extends.nil? ? "  protected EntityRepository _repository;\n" : ""
%><% entity.declared_attributes.select{ |attribute| !attribute.abstract? && attribute.imit.client_side? }.each do |attribute| %>
  private <%= annotated_type(attribute, :imit) %> _<%= attribute.imit.field_name %>;
<% if attribute.reference?
%>  private <%= "#{nullability_annotation(attribute.nullable?)} #{attribute.imit.transport_java_type}" %> _<%= attribute.imit.transport_name %>;
<%
   end
   end
%>

  protected <%= entity.imit.imitation_name %>( final EntityRepository repository )
  {
    <%= entity.extends.nil? ? "_repository = repository" : "super( repository )" %>;
  }
<% entity.declared_attributes.select{|attribute| attribute.abstract? && attribute.imit.client_side?}.each do |attribute|
%>  public abstract <%= annotated_type(attribute, :imit) %> get<%= attribute.imit.field_name %>();
<% if attribute.attribute_type == :reference
  %>  abstract <%= attribute.imit.transport_java_type %> get<%= attribute.imit.transport_name %>();
<% end %>
    abstract void set<%= attribute.imit.transport_name %>( <%= attribute.imit.transport_java_type %> value );
<% end %>
<% entity.declared_attributes.select{|attribute| !attribute.abstract? && attribute.imit.client_side?}.each do |attribute|
%>  public <%= annotated_type(attribute, :imit) %> get<%= attribute.imit.field_name %>()
  {
    checkValidity();
<% if attribute.attribute_type == :reference
%>    if( null == _<%= attribute.imit.field_name %> <%= attribute.nullable? ? "&& null != _#{attribute.referencing_link_name}" : "" %> )
    {
      _<%= attribute.imit.field_name %> = _repository.getByID( <%= attribute.referenced_entity.imit.qualified_imitation_name %>.class, _<%= attribute.referencing_link_name %> );
    }
  <% end
%>    return _<%= attribute.imit.field_name %>;
  }
<% if attribute.attribute_type == :reference
%>  <%= attribute.imit.transport_java_type %> get<%= attribute.imit.transport_name %>()
  {
    return _<%= attribute.referencing_link_name %>;
  }
<% end %>
  void set<%= attribute.imit.transport_name %>( final <%= attribute.imit.transport_java_type %> value )
  {
    checkValidity();
<% if attribute.attribute_type == :reference
%>    _<%= attribute.imit.field_name %> = null;
    _<%= attribute.referencing_link_name %> = value;
<% else
%>    _<%= attribute.imit.field_name %> = value;
<% end %>  }

<% end %>
  protected void invalidate()
  {
    <%= entity.extends.nil? ? "_repository = null" : "super.invalidate()" %>;
  }
<% if entity.extends.nil? %>
  protected final void checkValidity()
  {
    if( null == _repository )
    {
      throw new IllegalStateException( "Method invoked on invalid imitation" );
    }
  }
<% end %>
}