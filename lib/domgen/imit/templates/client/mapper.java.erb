/* DO NOT EDIT: File is auto-generated */
package <%= to_package(data_module.imit.qualified_mapper_name) %>;

/**
 * Utility class to map a change to an entity ensuring that the repository is updated as required.
 *
 * NOTE: This must be in the same package as the entities otherwise you will not be able to access the setters.
 */
@javax.annotation.Generated( "Domgen" )
@edu.umd.cs.findbugs.annotations.SuppressFBWarnings( { "RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE" } )
@java.lang.SuppressWarnings( { "UnusedDeclaration", "JavaDoc", "PMD.UnusedPrivateField", "PMD.CollapsibleIfStatements", "PMD.SingularField", "PMD.UnusedFormalParameter" } )
public class <%= data_module.imit.mapper_name %>
{
  private static final java.util.logging.Logger LOG = java.util.logging.Logger.getLogger( <%= data_module.imit.mapper_name %>.class.getName() );
<% data_module.entities.select{ |entity| entity.imit?  }.each do |entity|
  entity_prefix = "#{Reality::Naming.uppercase_constantize(entity.name)}_"
-%>
  private static final String <%= entity_prefix %>TYPE_KEY = "<%= entity.qualified_name %>";
<% entity.attributes.select{ |attribute| attribute.arez?  }.each do |attribute| -%>
  private static final String <%= entity_prefix %><%= Reality::Naming.uppercase_constantize( attribute.name ) %> = "<%= attribute.name %>";
<% end -%>
<% entity.referencing_attributes.select{ |attribute| attribute.arez? && !attribute.abstract? && attribute.inverse.arez? && attribute.inverse.arez.traversable?}.each do |attribute| -%>
  private static final String <%= entity_prefix %><%= Reality::Naming.uppercase_constantize(attribute.inverse.name) %> = "<%= attribute.inverse.name %>";
<% end -%>
<% end -%>

  private final org.realityforge.replicant.client.EntityLocator _entityLocator;
  private final <%= data_module.arez.qualified_data_module_repository_name %> _repository;
  private final org.realityforge.replicant.client.EntitySubscriptionManager _subscriptionManager;

  @javax.inject.Inject
  public <%= data_module.imit.mapper_name %>( @javax.annotation.Nonnull final org.realityforge.replicant.client.EntityLocator entityLocator, @javax.annotation.Nonnull final <%= data_module.arez.qualified_data_module_repository_name %> repository, @javax.annotation.Nonnull final org.realityforge.replicant.client.EntitySubscriptionManager subscriptionManager )
  {
    _entityLocator = java.util.Objects.requireNonNull( entityLocator );
    _repository = java.util.Objects.requireNonNull( repository );
    _subscriptionManager = java.util.Objects.requireNonNull( subscriptionManager );
  }
<% data_module.entities.select { |entity| entity.imit? }.each do |entity| -%>
<% if entity.concrete? -%>

  public Object applyChangeTo<%= entity.name %>( final org.realityforge.replicant.client.transport.Change change )
  {
<%
   designator_value =
        if entity.primary_key.imit.transport_characteristic_type_key == :integer
          'change.getDesignatorAsInt()'
        elsif entity.primary_key.imit.transport_characteristic_type_key == :text
          'change.getDesignatorAsString()'
        else
          Domgen.error("Unable to convert data type #{entity.primary_key.imit.transport_characteristic_type_key} on #{entity.primary_key.qualified_name}")
        end
-%>
    final <%= entity.primary_key.arez.java_type(:transport, :assume_generated => true) %> designator = (<%= entity.primary_key.arez.java_type(:transport, :assume_generated => true) %>) <%= designator_value %>;
    <%= entity.arez.name %> entity = _repository.<%= Reality::Naming.camelize(entity.dao.name) %>().findBy<%= entity.primary_key.name %>( designator );
    // If change is a delete...
    if( change.isRemove() )
    {
      if( null != entity )
      {
        // It is in the local repository so we need to delete it
        _repository.<%= Reality::Naming.camelize(entity.dao.name) %>().destroy( entity );
        _subscriptionManager.removeEntity( <%= entity.arez.name %>.class, designator );
      }
    }
    else
    {
      if( null == entity )
      {
<% entity.attributes.select{|attribute| attribute.arez?}.each do |attribute|
    key = "#{Reality::Naming.uppercase_constantize(entity.name)}_#{Reality::Naming.uppercase_constantize(attribute.name)}"
    value_converter =
        if attribute.imit.transport_characteristic_type_key == :date
          "change.getStringValue( #{key} )"
        elsif attribute.imit.transport_characteristic_type_key == :datetime
          "new java.util.Date( new java.math.BigDecimal( change.getStringValue( #{key} ) ).longValueExact() )"
        elsif attribute.imit.transport_characteristic_type_key == :integer
          "change.getIntegerValue( #{key} )"
        elsif attribute.imit.transport_characteristic_type_key == :real
          "change.getIntegerValue( #{key} )"
        elsif attribute.imit.transport_characteristic_type_key == :boolean
          "change.getBooleanValue( #{key} )"
        elsif attribute.imit.transport_characteristic_type_key == :text
          "change.getStringValue( #{key} )"
        elsif attribute.imit.transport_characteristic_type_key == :enumeration && attribute.enumeration.textual_values?
          "change.getStringValue( #{key} )"
        elsif attribute.imit.transport_characteristic_type_key == :enumeration && attribute.enumeration.numeric_values?
          "change.getIntegerValue( #{key} )"
        else
          raise "Unable to convert data type #{attribute.imit.transport_characteristic_type_key} on #{attribute.qualified_name}"
        end
-%>
        final <%= attribute.imit.java_type(:transport, :assume_generated => true) %> <%= Reality::Naming.camelize(attribute.name) %> = <%= attribute.nullable? ? "( change.isNull( #{key} ) ? null : #{value_converter} )" : value_converter %>;
<% end -%>
        entity = _repository.<%= Reality::Naming.camelize(entity.dao.name) %>().create( _entityLocator, <%= entity.attributes.select{|attribute| attribute.arez?}.collect{|attribute| Reality::Naming.camelize(attribute.name)}.join(', ') %> );
      }
      else
      {
        updateAttributes<%= entity.name %>( entity, change );
      }
      final org.realityforge.replicant.client.ChannelAddress[] descriptors = new org.realityforge.replicant.client.ChannelAddress[ change.getChannelCount() ];
      for ( int i = 0; i < descriptors.length; i++ )
      {
        descriptors[i] = new org.realityforge.replicant.client.ChannelAddress( <%= data_module.repository.imit.qualified_graph_enum_name %>.values()[change.getChannelID( i )], change.getSubChannelID( i ) );
      }
      _subscriptionManager.updateEntity( <%= entity.arez.name %>.class, designator, descriptors, entity );
    }
    return entity;
  }

<% end %>
  private void updateAttributes<%= entity.name %>( final <%= entity.arez.name %> entity, final org.realityforge.replicant.client.transport.Change change )
  {
<% if entity.extends
   other = entity.data_module.entity_by_name(entity.extends) -%>
    updateAttributes<%= other.name %>( entity, change );
<% end -%>
<% entity.declared_attributes.select{|attribute| attribute.arez? && !attribute.immutable?}.each do |attribute|
    key = "#{Reality::Naming.uppercase_constantize(entity.name)}_#{Reality::Naming.uppercase_constantize(attribute.name)}"
    value_converter =
        if attribute.imit.transport_characteristic_type_key == :date
          "change.getStringValue( #{key} )"
        elsif attribute.imit.transport_characteristic_type_key == :datetime
          "new java.util.Date( new java.math.BigDecimal( change.getStringValue( #{key} ) ).longValueExact() )"
        elsif attribute.imit.transport_characteristic_type_key == :integer
          "change.getIntegerValue( #{key} )"
        elsif attribute.imit.transport_characteristic_type_key == :real
          "change.getIntegerValue( #{key} )"
        elsif attribute.imit.transport_characteristic_type_key == :boolean
          "change.getBooleanValue( #{key} )"
        elsif attribute.imit.transport_characteristic_type_key == :text
          "change.getStringValue( #{key} )"
        elsif attribute.imit.transport_characteristic_type_key == :enumeration && attribute.enumeration.textual_values?
          "change.getStringValue( #{key} )"
        elsif attribute.imit.transport_characteristic_type_key == :enumeration && attribute.enumeration.numeric_values?
          "change.getIntegerValue( #{key} )"
        else
          raise "Unable to convert data type #{attribute.imit.transport_characteristic_type_key} on #{attribute.qualified_name}"
        end
-%>
    if( change.containsKey( <%= key %> ) )
    {
      entity.set<%= attribute.imit.name(:transport) %>( <%= attribute.nullable? ? "( change.isNull( #{key} ) ? null : #{value_converter} )" : value_converter %> );
    }
<% end -%>
  }
<% end -%>
}
