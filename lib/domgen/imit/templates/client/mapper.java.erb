/* DO NOT EDIT: File is auto-generated */
package <%= to_package(data_module.imit.qualified_mapper_name) %>;

/**
 * Utility class to map a change to an entity ensuring that the repository is updated as required.
 *
 * NOTE: This must be in the same package as the entities otherwise you will not be able to access the setters.
 */
@javax.annotation.Generated( "Domgen" )
@edu.umd.cs.findbugs.annotations.SuppressFBWarnings( { "RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE" } )
@java.lang.SuppressWarnings( { "UnusedDeclaration", "JavaDoc", "PMD.UnusedPrivateField", "PMD.CollapsibleIfStatements", "PMD.SingularField", "PMD.UnusedFormalParameter" } )
public class <%= data_module.imit.mapper_name %>
{
  private static final java.util.logging.Logger LOG = java.util.logging.Logger.getLogger( <%= data_module.imit.mapper_name %>.class.getName() );
<% data_module.entities.select{ |entity| entity.imit?  }.each do |entity|
  entity_prefix = "#{Reality::Naming.uppercase_constantize(entity.name)}_"
-%>
  private static final String <%= entity_prefix %>TYPE_KEY = "<%= entity.qualified_name %>";
<% entity.attributes.select{ |attribute| attribute.arez?  }.each do |attribute| -%>
  private static final String <%= entity_prefix %><%= Reality::Naming.uppercase_constantize( attribute.name ) %> = "<%= attribute.name %>";
<% end -%>
<% entity.referencing_attributes.select{ |attribute| attribute.arez? && !attribute.abstract? && attribute.inverse.arez? && attribute.inverse.arez.traversable?}.each do |attribute| -%>
  private static final String <%= entity_prefix %><%= Reality::Naming.uppercase_constantize(attribute.inverse.name) %> = "<%= attribute.inverse.name %>";
<% end -%>
<% end -%>

  private final org.realityforge.replicant.client.EntityLocator _entityLocator;
  private final <%= data_module.arez.qualified_data_module_repository_name %> _repository;

  @javax.inject.Inject
  public <%= data_module.imit.mapper_name %>( @javax.annotation.Nonnull final org.realityforge.replicant.client.EntityLocator entityLocator, @javax.annotation.Nonnull final <%= data_module.arez.qualified_data_module_repository_name %> repository )
  {
    _entityLocator = java.util.Objects.requireNonNull( entityLocator );
    _repository = java.util.Objects.requireNonNull( repository );
  }
<% data_module.entities.select { |entity| entity.imit? }.each do |entity| -%>
<% if entity.concrete? -%>

  public Object applyChangeTo<%= entity.name %>( final replicant.EntityChange change )
  {
    final int $id = change.getId();
    <%= entity.arez.name %> entity = _repository.<%= Reality::Naming.camelize(entity.dao.name) %>().findBy<%= entity.primary_key.name %>( $id );
    if( change.isRemove() )
    {
      if( null != entity )
      {
        _repository.<%= Reality::Naming.camelize(entity.dao.name) %>().destroy( entity );
      }
    }
    else
    {
      final replicant.EntityChangeData data = change.getData();
      if( null == entity )
      {
<% entity.attributes.select{|attribute| attribute.arez?}.each do |attribute|
    key = "#{Reality::Naming.uppercase_constantize(entity.name)}_#{Reality::Naming.uppercase_constantize(attribute.name)}"
    value_converter =
        if attribute.imit.transport_characteristic_type_key == :date
          "data.getStringValue( #{key} )"
        elsif attribute.imit.transport_characteristic_type_key == :datetime
          "new java.util.Date( new java.math.BigDecimal( data.getStringValue( #{key} ) ).longValueExact() )"
        elsif attribute.imit.transport_characteristic_type_key == :integer
          "data.getIntegerValue( #{key} )"
        elsif attribute.imit.transport_characteristic_type_key == :real
          "data.getIntegerValue( #{key} )"
        elsif attribute.imit.transport_characteristic_type_key == :boolean
          "data.getBooleanValue( #{key} )"
        elsif attribute.imit.transport_characteristic_type_key == :text
          "data.getStringValue( #{key} )"
        elsif attribute.imit.transport_characteristic_type_key == :enumeration && attribute.enumeration.textual_values?
          "data.getStringValue( #{key} )"
        elsif attribute.imit.transport_characteristic_type_key == :enumeration && attribute.enumeration.numeric_values?
          "data.getIntegerValue( #{key} )"
        else
          raise "Unable to convert data type #{attribute.imit.transport_characteristic_type_key} on #{attribute.qualified_name}"
        end
-%>
        final <%= attribute.imit.java_type(:transport, :assume_generated => true) %> <%= Reality::Naming.camelize(attribute.name) %> = <%= attribute.nullable? ? "( data.isNull( #{key} ) ? null : #{value_converter} )" : value_converter %>;
<% end -%>
        entity = _repository.<%= Reality::Naming.camelize(entity.dao.name) %>().create( _entityLocator, <%= entity.attributes.select{|attribute| attribute.arez?}.collect{|attribute| Reality::Naming.camelize(attribute.name)}.join(', ') %> );
      }
      else
      {
        updateAttributes<%= entity.name %>( entity, data );
      }
      final replicant.Entity e = replicant.Replicant.context().findOrCreateEntity( <%= entity.arez.name %>.class, $id );
      e.setUserObject( entity );
      final replicant.EntityChannel[] changeCount = change.getChannels();
      for ( final replicant.EntityChannel entityChannel : changeCount )
      {
        final replicant.Subscription subscription = replicant.Replicant.context().findSubscription( new replicant.ChannelAddress( <%= data_module.repository.imit.qualified_graph_enum_name %>.values()[ entityChannel.getId() ], entityChannel.hasSubChannelId() ? entityChannel.getSubChannelId() : null ) );
        // TODO: Improve handling of this error scenario
        assert null != subscription;
        e.linkToSubscription( subscription );
      }
    }
    return entity;
  }

<% end %>
  private void updateAttributes<%= entity.name %>( final <%= entity.arez.name %> entity, final replicant.EntityChangeData data )
  {
<% if entity.extends
   other = entity.data_module.entity_by_name(entity.extends) -%>
    updateAttributes<%= other.name %>( entity, change );
<% end -%>
<% entity.declared_attributes.select{|attribute| attribute.arez? && !attribute.immutable?}.each do |attribute|
    key = "#{Reality::Naming.uppercase_constantize(entity.name)}_#{Reality::Naming.uppercase_constantize(attribute.name)}"
    value_converter =
        if attribute.imit.transport_characteristic_type_key == :date
          "data.getStringValue( #{key} )"
        elsif attribute.imit.transport_characteristic_type_key == :datetime
          "new java.util.Date( new java.math.BigDecimal( data.getStringValue( #{key} ) ).longValueExact() )"
        elsif attribute.imit.transport_characteristic_type_key == :integer
          "data.getIntegerValue( #{key} )"
        elsif attribute.imit.transport_characteristic_type_key == :real
          "data.getIntegerValue( #{key} )"
        elsif attribute.imit.transport_characteristic_type_key == :boolean
          "data.getBooleanValue( #{key} )"
        elsif attribute.imit.transport_characteristic_type_key == :text
          "data.getStringValue( #{key} )"
        elsif attribute.imit.transport_characteristic_type_key == :enumeration && attribute.enumeration.textual_values?
          "data.getStringValue( #{key} )"
        elsif attribute.imit.transport_characteristic_type_key == :enumeration && attribute.enumeration.numeric_values?
          "data.getIntegerValue( #{key} )"
        else
          raise "Unable to convert data type #{attribute.imit.transport_characteristic_type_key} on #{attribute.qualified_name}"
        end
-%>
    if( data.containsKey( <%= key %> ) )
    {
      entity.set<%= attribute.imit.name(:transport) %>( <%= attribute.nullable? ? "( data.isNull( #{key} ) ? null : #{value_converter} )" : value_converter %> );
    }
<% end -%>
  }
<% end -%>
}
