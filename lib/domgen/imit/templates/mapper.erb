/* DO NOT EDIT: File is auto-generated */
package <%= data_module.imit.imitation_package %>;

import org.realityforge.replicant.client.EntityChangeBroker;
import org.realityforge.replicant.client.EntityRepository;

/**
 * Utility class to map a change to an entity ensuring that the repository is updated as required.
 */
@javax.annotation.Generated( "Domgen" )
@SuppressWarnings( { "UnusedDeclaration", "JavaDoc" } )
public class <%= data_module.imit.mapper_name %>
{
  private static final java.util.logging.Logger LOG = java.util.logging.Logger.getLogger( <%= data_module.imit.mapper_name %>.class.getName() );

  private final EntityRepository _repository;
  private final EntityChangeBroker _broker;
  private final <%= data_module.imit.updater_name %> _<%= data_module.name %>Updater;

  @javax.inject.Inject
  public <%= data_module.imit.mapper_name %>( final @javax.annotation.Nonnull EntityRepository repository, final @javax.annotation.Nonnull EntityChangeBroker broker )
  {
    _repository = repository;
    _broker = broker;
    _<%= data_module.name %>Updater = new <%= data_module.imit.updater_name %>( broker );
  }

<% data_module.imit.client_side_entities.each do |entity| %>
<% if !entity.abstract? %>
  public Object applyChangeTo<%= entity.name %>( final Object id, final java.util.Map<String, java.io.Serializable> attributes )
  {
    <%= entity.imit.name %> entity = _repository.findByID( <%= entity.imit.name %>.class, id );
    // If change is a delete...
    if( null == attributes )
    {
      if( null != entity )
      {
        if( _broker.isEnabled() && LOG.isLoggable( java.util.logging.Level.FINE ) )
        {
          LOG.log( java.util.logging.Level.FINE, "applyChangeTo<%= entity.name %>('" + id + "') is deleting local entity" );
        }
        // It is in the local repository so we need to delete it
        _repository.deregisterEntity( <%= entity.imit.name %>.class, id );
         _<%= data_module.name %>Updater.delete<%= entity.name %>( entity );
      }
    }
    else
    {
      boolean fullUpdate = false;
      if( null == entity )
      {
        entity = new <%= entity.imit.name %>( _repository );
        _repository.registerEntity( <%= entity.imit.name %>.class, id, entity );
        fullUpdate = true;
        if( _broker.isEnabled() && LOG.isLoggable( java.util.logging.Level.FINE ) )
        {
          LOG.log( java.util.logging.Level.FINE, "applyChangeTo<%= entity.name %>('" + id + "') is creating local entity" );
        }
      }
      else
      {
        if( _broker.isEnabled() && LOG.isLoggable( java.util.logging.Level.FINE ) )
        {
          LOG.log( java.util.logging.Level.FINE, "applyChangeTo<%= entity.name %>('" + id + "') is updating local entity" );
        }
      }
      updateAttributes<%= entity.name %>( entity, attributes, fullUpdate );
    }
    return entity;
  }

<% end %>
  private void updateAttributes<%= entity.name %>( final <%= entity.imit.name %> entity, final java.util.Map<String, java.io.Serializable> attributes, final boolean fullUpdate )
  {
<% if entity.extends
   other = entity.data_module.entity_by_name(entity.extends)
%>    updateAttributes<%= other.name %>( entity, attributes, fullUpdate );
<% end %>
<% entity.declared_attributes.select{|attribute| attribute.imit.client_side? }.each do |attribute|
    value_converter =
        if attribute.imit.characteristic_type(:transport) == :datetime
          "new java.sql.Timestamp( ( (Number) value ).longValue() )"
        elsif attribute.imit.characteristic_type(:transport) == :integer
          "( (Number) value ).intValue()"
        elsif attribute.imit.characteristic_type(:transport) == :real
          "( (Double) value ).doubleValue()"
        elsif attribute.imit.characteristic_type(:transport) == :boolean
          "( (Boolean) value ).booleanValue()"
        elsif attribute.imit.characteristic_type(:transport) == :text
          "( (String) value )"
        elsif attribute.imit.characteristic_type(:transport) == :enumeration && attribute.enumeration.textual_values?
          "#{attribute.enumeration.imit.qualified_name}.valueOf( (String) value )"
        elsif attribute.imit.characteristic_type(:transport) == :enumeration && attribute.enumeration.numeric_values?
          "( (Number) value ).intValue()"
        else
          raise "Unable to convert data type #{attribute.imit.characteristic_type(:transport)} on #{attribute.qualified_name}"
        end
%>    if( fullUpdate <% if !attribute.primary_key? %>|| attributes.containsKey( <%= entity.name %>.<%= uppercase_constantize( attribute.name ) %> )<% end %> )
    {
      final Object value = attributes.get( <%= entity.name %>.<%= uppercase_constantize(attribute.name) %> );
      _<%= data_module.name %>Updater.set<%= attribute.imit.name(:transport) %>_On_<%= entity.name %>( entity, <%= attribute.nullable? ? "( null != value ? #{value_converter} : null )" : value_converter %> );
    }
<% end %>
  }
<% end %>
}
