/* DO NOT EDIT: File is auto-generated */
package <%= repository.imit.imitation_package %>;

import org.realityforge.imit.client.EntityChangeBroker;
import org.realityforge.imit.client.EntityRepository;
import org.realityforge.imit.shared.gwt_json.TransportUtil;

/**
 * Utility class that decodes JSON payloads and applies the changes to the entities
 * in the associated entity repository for the repository "<%= repository.name %>".
 */
@javax.annotation.Generated( "Domgen" )
@SuppressWarnings( { "UnusedDeclaration", "JavaDoc" } )
public class <%= repository.imit.json_mapper_name %>
  implements org.realityforge.imit.shared.gwt_json.JsonGwtChangeMapper
{
<% repository.imit.client_side_data_modules.each do |data_module|
%>  private final <%= data_module.imit.qualified_mapper_name %> _<%= data_module.name %>;
<% end %>
  @javax.inject.Inject
  public <%= repository.imit.json_mapper_name %>( <%= repository.imit.client_side_data_modules.collect { |data_module| "final #{data_module.imit.qualified_mapper_name} #{data_module.name}" }.join(", ") %>
)
  {
<% repository.imit.client_side_data_modules.each do |data_module|
%>    _<%= data_module.name %> = <%= data_module.name %>;
<% end %>
  }

@Override
  public void apply( final com.google.gwt.json.client.JSONValue changeSet )
  {
    final com.google.gwt.json.client.JSONArray array =
      TransportUtil.toArray( TransportUtil.toObject( changeSet, "changeset" ).get( TransportUtil.CHANGES ),
                             TransportUtil.CHANGES );
    if ( null == array )
    {
      throw new IllegalStateException( TransportUtil.CHANGES + " is not an array" );
    }
    final int size = array.size();
    for ( int i = 0; i < size; i++ )
    {
      applyChange( TransportUtil.toObject( array.get( i ), "change[" + i + "]" ) );
    }
  }

  private void applyChange( final com.google.gwt.json.client.JSONObject change )
  {
    final int typeID = TransportUtil.toInteger( change.get( TransportUtil.TYPE_ID ), "type" );
    final java.util.Map<String, java.io.Serializable> data = change.containsKey( TransportUtil.DATA ) ? TransportUtil.toMap( TransportUtil.toObject( change.get( TransportUtil.DATA ), TransportUtil.DATA ) ) : null;
    switch( typeID )
    {
<% repository.imit.concrete_client_side_entities.each do |entity|
  at = entity.primary_key.reference? ? entity.primary_key.referenced_entity.primary_key.attribute_type : entity.primary_key.attribute_type
  primary_key_converter =
    if at == :integer
      "Integer"
    elsif at == :text
      "String"
    elsif at == :real
      "Double"
    else
      raise "Unknown primary key type #{at}"
    end
%>      case <%= entity.imit.qualified_imitation_name %>.TRANSPORT_ID:
        {
          final Object id = TransportUtil.to<%= primary_key_converter %>( change.get( TransportUtil.ENTITY_ID ), "id" );
          _<%= entity.data_module.name %>.applyChangeTo<%= entity.name %>( id, data );
          break;
        }
<% end %>
      default: throw new IllegalArgumentException("Unknown typeID = " + typeID);
    }
  }
}
